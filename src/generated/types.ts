/**
 * <auto-generated />
 */

import {
    BotComponentChangeKind,
    BotElementKind,
    DiagnosticResultKind,
    PropertyPathKind,
    DataTypeKind,
    DataValueKind,
    BotElementDiagnosticKind,
    BotElementSuggestionKind,
    WasmCommandKind,
    WasmCommandResponseKind,
    WasmLogKind
} from "./kinds";
import {
    StateCode,
    ProvisioningStatus,
    VariableScope,
    ConversationOutcome,
    ListStyle,
    VariablesToClear,
    ArrayChangeType,
    ResponseTypes,
    HttpMethod,
    HandoffVariablesList,
    ActionType,
    PublishResult,
    BotAccessControlPolicy,
    BotAuthenticationMode,
    BotAuthenticationTrigger,
    BotComponentReusePolicy,
    Language,
    AttachmentOutputFormat,
    ChoiceOutputFormat,
    ActivityImportance,
    AttachmentLayout,
    InputHint,
    PrebuiltEntityName,
    ExpressionErrorCode,
    ValidationErrorCode,
    ReferenceType,
    InvalidReferenceErrorCode,
    ActivityType,
    ChannelId,
    BooleanConditionOperator,
    WasmBrowserTelemetryLogLevel,
    SystemOptionSetName
} from "./enums";
import {
    TriggerId,
    DialogSchemaName,
    TriggerSchemaName,
    CustomEntitySchemaName,
    GlobalVariableSchemaName,
    ActionId,
    ClosedListItemId,
    SkillSchemaName,
    BotComponentId,
    BotEntityId,
    EnvironmentVariableDefinitionSchemaName,
    BotEntitySchemaName,
    SkillActionId,
    FlowId,
    OptionName
} from "./idTypes";
import {
    Guid,
    DateTime,
    TimeSpan
} from "./valueTypes";
import { ExpressionBase } from "./customElements";
import { generateDesignerId } from './idGenerator';

/**
 * Makes only properties of T in type K optional.
 */
export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
/**
 * Removes properties in type KOmit from T and makes properties of T in type KPartial optional.
 */
export type OmitPartial<T, KOmit extends keyof T, KPartial extends keyof T> = Omit<T, KOmit | KPartial> & Partial<Pick<T, KPartial>>
export type Dictionary<TValue> = { [property: string]: TValue }
export type RecordDataValue = { [property: string]: DataValue }
export type DataValue = string | boolean | number | OptionDataValue | RecordDataValue
export type PropertyPath = string;
/**
 * Base class for a Dataverse solution component.
 */
export interface SolutionComponent extends BotElement
{
    /**
     * ETag / Version Number in Dataverse.
     */
    version?: number;
    managedProperties?: ManagedProperties;
    auditInfo?: AuditInfo;
    /**
     * The user-specified display name.
     */
    displayName?: string;
}



/**
 * Class containing the properties from the Bot entity.
 */
export interface BotEntity extends SolutionComponent
{
    readonly $kind: BotElementKind.BotEntity;
    /**
     * Unique name of the bot in Dataverse. This is the same across different environments.
     */
    schemaName: BotEntitySchemaName;
    /**
     * Unique identifier for the Chatbot in Dataverse. This is different in each environment.
     */
    cdsBotId: BotEntityId;
    accessControlPolicy?: BotAccessControlPolicy;
    authenticationMode?: BotAuthenticationMode;
    authenticationTrigger?: BotAuthenticationTrigger;
    authorizedSecurityGroupIds: Guid[];
    teamsAppInformation?: TeamsApplicationDetails;
    /**
     * Stores bot configuration data.
     */
    configuration?: BotConfiguration;
    /**
     * Date and time when the Chatbot was last published
     */
    publishedOn?: DateTime;
    /**
     * Stores bot synchronization information
     */
    synchronizationStatus?: BotSynchronizationDetails;
    /**
     * Used to visually identify your bot in channels and services. Represented in a base64 encoded string. Must be in PNG format, and no larger than 30K in size. This value can be changed at any time.
     */
    iconBase64?: string;
    /**
     * Language of the bot.
     */
    language?: Language;
    /**
     * The statecode of the component
     */
    state?: StateCode;
    /**
     * The provisioning state of the bot
     */
    status?: ProvisioningStatus;
}

/**
 * Creates a `BotEntity` object with the given arguments
 */
export const makeBotEntity = (value: OmitPartial<BotEntity, '$kind', 'authorizedSecurityGroupIds' | 'diagnostics'>): BotEntity => ({
    $kind: BotElementKind.BotEntity,
    authorizedSecurityGroupIds: [],
    diagnostics: [],
    ...value
});


export interface CloudFlowDefinition extends SolutionComponent
{
    readonly $kind: BotElementKind.CloudFlowDefinition;
    /**
     * Id of the flow. This is a unique identifier of the environment variable definition in Dataverse. This is the same across different environments.
     */
    id: FlowId;
    inputType?: RecordDataType;
    outputType?: RecordDataType;
}

/**
 * Creates a `CloudFlowDefinition` object with the given arguments
 */
export const makeCloudFlowDefinition = (value: OmitPartial<CloudFlowDefinition, '$kind', 'diagnostics'>): CloudFlowDefinition => ({
    $kind: BotElementKind.CloudFlowDefinition,
    diagnostics: [],
    ...value
});


export interface EnvironmentVariableDefinition extends SolutionComponent
{
    readonly $kind: BotElementKind.EnvironmentVariableDefinition;
    /**
     * Unique name of the environment variable definition in Dataverse. This is the same across different environments.
     */
    schemaName: EnvironmentVariableDefinitionSchemaName;
    id?: Guid;
    defaultValue?: string;
    valueComponent?: EnvironmentVariableValue;
}

/**
 * Creates a `EnvironmentVariableDefinition` object with the given arguments
 */
export const makeEnvironmentVariableDefinition = (value: OmitPartial<EnvironmentVariableDefinition, '$kind', 'diagnostics'>): EnvironmentVariableDefinition => ({
    $kind: BotElementKind.EnvironmentVariableDefinition,
    diagnostics: [],
    ...value
});


export interface EnvironmentVariableValue extends SolutionComponent
{
    readonly $kind: BotElementKind.EnvironmentVariableValue;
    id?: Guid;
    value?: string;
}

/**
 * Creates a `EnvironmentVariableValue` object with the given arguments
 */
export const makeEnvironmentVariableValue = (value?: OmitPartial<EnvironmentVariableValue, '$kind', 'diagnostics'>): EnvironmentVariableValue => ({
    $kind: BotElementKind.EnvironmentVariableValue,
    diagnostics: [],
    ...value
});


export interface BotComponentBase extends SolutionComponent
{
    id?: BotComponentId;
    parentBotComponentId?: BotComponentId;
    description?: string;
    shareContext?: ContentShareContext;
    /**
     * The category of this bot component.
     */
    category?: string;
    language?: Language;
}



export interface DialogComponent extends BotComponentBase
{
    readonly $kind: BotElementKind.DialogComponent;
    /**
     * Unique name of the dialog component in Dataverse. This is the same across different environments.
     */
    schemaName: DialogSchemaName;
    dialog: AdaptiveDialog;
}

/**
 * Creates a `DialogComponent` object with the given arguments
 */
export const makeDialogComponent = (value: OmitPartial<DialogComponent, '$kind', 'diagnostics'>): DialogComponent => ({
    $kind: BotElementKind.DialogComponent,
    diagnostics: [],
    ...value
});


/**
 * The bot component containing triggers in the main dialog.
 */
export interface TriggerComponent extends BotComponentBase
{
    readonly $kind: BotElementKind.TriggerComponent;
    /**
     * Unique name of the trigger component in Dataverse. This is the same across different environments.
     */
    schemaName: TriggerSchemaName;
    /**
     * The trigger of the main dialog with its templates and entities.
     */
    standaloneTrigger: StandaloneTrigger;
}

/**
 * Creates a `TriggerComponent` object with the given arguments
 */
export const makeTriggerComponent = (value: OmitPartial<TriggerComponent, '$kind', 'diagnostics'>): TriggerComponent => ({
    $kind: BotElementKind.TriggerComponent,
    diagnostics: [],
    ...value
});


export interface CustomEntityComponent extends BotComponentBase
{
    readonly $kind: BotElementKind.CustomEntityComponent;
    /**
     * Unique name of the custom entit component in Dataverse. This is the same across different environments.
     */
    schemaName: CustomEntitySchemaName;
    entity: Entity;
}

/**
 * Creates a `CustomEntityComponent` object with the given arguments
 */
export const makeCustomEntityComponent = (value: OmitPartial<CustomEntityComponent, '$kind', 'diagnostics'>): CustomEntityComponent => ({
    $kind: BotElementKind.CustomEntityComponent,
    diagnostics: [],
    ...value
});


export interface GlobalVariableComponent extends BotComponentBase
{
    readonly $kind: BotElementKind.GlobalVariableComponent;
    /**
     * Unique name of the variable component in Dataverse. This is the same across different environments.
     */
    schemaName: GlobalVariableSchemaName;
    variable: StandaloneVariable;
}

/**
 * Creates a `GlobalVariableComponent` object with the given arguments
 */
export const makeGlobalVariableComponent = (value: OmitPartial<GlobalVariableComponent, '$kind', 'diagnostics'>): GlobalVariableComponent => ({
    $kind: BotElementKind.GlobalVariableComponent,
    diagnostics: [],
    ...value
});


export interface SkillComponent extends BotComponentBase
{
    readonly $kind: BotElementKind.SkillComponent;
    /**
     * Unique name of the skill component in Dataverse. This is the same across different environments.
     */
    schemaName: SkillSchemaName;
    skill: SkillDefinition;
}

/**
 * Creates a `SkillComponent` object with the given arguments
 */
export const makeSkillComponent = (value: OmitPartial<SkillComponent, '$kind', 'diagnostics'>): SkillComponent => ({
    $kind: BotElementKind.SkillComponent,
    diagnostics: [],
    ...value
});


export interface LegacyOrUnknownComponent extends BotComponentBase
{
    readonly $kind: BotElementKind.LegacyOrUnknownComponent;
    componentTypeInt?: number;
    /**
     * Component unique name in Dataverse. This is the same across different environments.
     */
    schemaName: string;
    content?: string;
    data?: string;
}

/**
 * Creates a `LegacyOrUnknownComponent` object with the given arguments
 */
export const makeLegacyOrUnknownComponent = (value: OmitPartial<LegacyOrUnknownComponent, '$kind', 'diagnostics'>): LegacyOrUnknownComponent => ({
    $kind: BotElementKind.LegacyOrUnknownComponent,
    diagnostics: [],
    ...value
});


/**
 * Used to read and write changes to BotComponentBase objects in the system.
 */
export interface BotComponentChangeSet
{
    /**
     * List of changes retrieved or to be applied.
     */
    changes: BotComponentChange[];
    /**
     * Token representing the current set of changes received.
     */
    changeToken?: string;
}



export interface BotComponentChange
{
    readonly $kind: BotComponentChangeKind;
}



export interface BotComponentUpsert extends BotComponentChange
{
    component?: BotComponentBase;
}



export interface BotComponentInsert extends BotComponentUpsert
{
    readonly $kind: BotComponentChangeKind.BotComponentInsert;
}

/**
 * Creates a `BotComponentInsert` object with the given arguments
 */
export const makeBotComponentInsert = (value?: Omit<BotComponentInsert, '$kind'>): BotComponentInsert => ({
    $kind: BotComponentChangeKind.BotComponentInsert,
    ...value
});


export interface BotComponentUpdate extends BotComponentUpsert
{
    readonly $kind: BotComponentChangeKind.BotComponentUpdate;
    /**
     * True if the version number was lower than before, due to a backup restore or unmanaged layer removal.
     */
    wasVersionDowngrade?: boolean;
}

/**
 * Creates a `BotComponentUpdate` object with the given arguments
 */
export const makeBotComponentUpdate = (value?: Omit<BotComponentUpdate, '$kind'>): BotComponentUpdate => ({
    $kind: BotComponentChangeKind.BotComponentUpdate,
    ...value
});


export interface BotComponentDelete extends BotComponentChange
{
    readonly $kind: BotComponentChangeKind.BotComponentDelete;
    botComponentId: BotComponentId;
    versionNumber?: number;
}

/**
 * Creates a `BotComponentDelete` object with the given arguments
 */
export const makeBotComponentDelete = (value: Omit<BotComponentDelete, '$kind'>): BotComponentDelete => ({
    $kind: BotComponentChangeKind.BotComponentDelete,
    ...value
});


/**
 * Represents the root of declarative Dialogs, Triggers, Templates and Bot Components.
 */
export interface BotElement
{
    readonly $kind: BotElementKind;
    /**
     * List of diagnostics attached to this BotElement. Only serializable in Json
     */
    diagnostics: BotElementDiagnostic[];
    /**
     * Fields that were deserialized but not understood by the model
     */
    extensionData?: RecordDataValue;
}



/**
 * Root element for a complete bot, with metadata attributes about the bot, as well as its components.
 */
export interface BotDefinition extends BotElement
{
    readonly $kind: BotElementKind.BotDefinition;
    /**
     * Gets the BAP environment ID for the bot.
     */
    environmentId?: string;
    /**
     * Gets all information about the bot in Dataverse.
     */
    entity: BotEntity;
    /**
     * BCR connection name that should be used to authenticate the user
     */
    authenticationConnectionName?: string;
    /**
     * List of bot components that build this bot
     */
    components: BotComponentBase[];
    /**
     * List of environment variables used by this bot
     */
    environmentVariables: EnvironmentVariableDefinition[];
    /**
     * List of cloud flows used by this bot
     */
    flows: CloudFlowDefinition[];
}

/**
 * Creates a `BotDefinition` object with the given arguments
 */
export const makeBotDefinition = (value: OmitPartial<BotDefinition, '$kind', 'components' | 'environmentVariables' | 'flows' | 'diagnostics'>): BotDefinition => ({
    $kind: BotElementKind.BotDefinition,
    components: [],
    environmentVariables: [],
    flows: [],
    diagnostics: [],
    ...value
});


export interface SkillDefinition extends BotElement
{
    readonly $kind: BotElementKind.SkillDefinition;
    appId: EnvironmentVariableReference;
    appEndpoint: EnvironmentVariableReference;
    name?: string;
    manifestVersion?: string;
    privacyPolicy?: string;
    description?: string;
    actions: SkillActionDefinition[];
}

/**
 * Creates a `SkillDefinition` object with the given arguments
 */
export const makeSkillDefinition = (value: OmitPartial<SkillDefinition, '$kind', 'actions' | 'diagnostics'>): SkillDefinition => ({
    $kind: BotElementKind.SkillDefinition,
    actions: [],
    diagnostics: [],
    ...value
});


export interface EnvironmentVariableReference extends BotElement
{
    readonly $kind: BotElementKind.EnvironmentVariableReference;
    schemaName: EnvironmentVariableDefinitionSchemaName;
}

/**
 * Creates a `EnvironmentVariableReference` object with the given arguments
 */
export const makeEnvironmentVariableReference = (value: OmitPartial<EnvironmentVariableReference, '$kind', 'diagnostics'>): EnvironmentVariableReference => ({
    $kind: BotElementKind.EnvironmentVariableReference,
    diagnostics: [],
    ...value
});


export interface SkillActionDefinition extends BotElement
{
    readonly $kind: BotElementKind.SkillActionDefinition;
    activityType?: string;
    actionId: SkillActionId;
    title?: string;
    description?: string;
    inputType?: RecordDataType;
    outputType?: RecordDataType;
}

/**
 * Creates a `SkillActionDefinition` object with the given arguments
 */
export const makeSkillActionDefinition = (value: OmitPartial<SkillActionDefinition, '$kind', 'diagnostics'>): SkillActionDefinition => ({
    $kind: BotElementKind.SkillActionDefinition,
    diagnostics: [],
    ...value
});


export interface Recognizer extends BotElement
{
}



/**
 * Regex recognizer pattern and intent definition..
 */
export interface RegexIntentPattern extends BotElement
{
    readonly $kind: BotElementKind.RegexIntentPattern;
    /**
     * Intent name
     */
    intent: string;
    /**
     * Regex pattern
     */
    pattern: string;
}

/**
 * Creates a `RegexIntentPattern` object with the given arguments
 */
export const makeRegexIntentPattern = (value: OmitPartial<RegexIntentPattern, '$kind', 'diagnostics'>): RegexIntentPattern => ({
    $kind: BotElementKind.RegexIntentPattern,
    diagnostics: [],
    ...value
});


/**
 * Recognizer implementation which uses regex expressions to identify intents.
 */
export interface RegexRecognizer extends Recognizer
{
    readonly $kind: BotElementKind.RegexRecognizer;
    /**
     * Collection of intent definitions.
     */
    intents: RegexIntentPattern[];
}

/**
 * Creates a `RegexRecognizer` object with the given arguments
 */
export const makeRegexRecognizer = (value?: OmitPartial<RegexRecognizer, '$kind', 'intents' | 'diagnostics'>): RegexRecognizer => ({
    $kind: BotElementKind.RegexRecognizer,
    intents: [],
    diagnostics: [],
    ...value
});


/**
 * Recognizer implementation which uses Power Virtual Agents recognition.
 */
export interface VirtualAgentsRecognizer extends Recognizer
{
    readonly $kind: BotElementKind.VirtualAgentsRecognizer;
}

/**
 * Creates a `VirtualAgentsRecognizer` object with the given arguments
 */
export const makeVirtualAgentsRecognizer = (value?: OmitPartial<VirtualAgentsRecognizer, '$kind', 'diagnostics'>): VirtualAgentsRecognizer => ({
    $kind: BotElementKind.VirtualAgentsRecognizer,
    diagnostics: [],
    ...value
});


export interface Intent extends BotElement
{
    readonly $kind: BotElementKind.Intent;
    /**
     * The display name of the intent to display to the user during intent disambiguation.
     */
    displayName?: StringExpression;
    /**
     * List of trigger queries authored by the user.
     */
    triggerQueries: string[];
    /**
     * List of Additional Trigger queries that are generated by the background AI job based of bot's traffic analysis.
     */
    generatedTriggerQueries: string[];
    /**
     * List of channels that the intent is available in.
     */
    availableInChannels?: ArrayExpression<string>;
}

/**
 * Creates a `Intent` object with the given arguments
 */
export const makeIntent = (value?: OmitPartial<Intent, '$kind', 'triggerQueries' | 'generatedTriggerQueries' | 'diagnostics'>): Intent => ({
    $kind: BotElementKind.Intent,
    triggerQueries: [],
    generatedTriggerQueries: [],
    diagnostics: [],
    ...value
});


/**
 * The trigger on the main dialog that was imported from Composer.
 */
export interface StandaloneTrigger extends BotElement
{
    readonly $kind: BotElementKind.StandaloneTrigger;
    /**
     * The trigger that is attached to the main dialog.
     */
    trigger?: TriggerBase;
}

/**
 * Creates a `StandaloneTrigger` object with the given arguments
 */
export const makeStandaloneTrigger = (value?: OmitPartial<StandaloneTrigger, '$kind', 'diagnostics'>): StandaloneTrigger => ({
    $kind: BotElementKind.StandaloneTrigger,
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when condition is true
 */
export interface TriggerBase extends BotElement
{
    /**
     * The actions to add to the plan when the rule constraints are met.
     */
    actions: DialogAction[];
    /**
     * The value of the unique id for this condition
     */
    id: TriggerId;
    /**
     * The condition which needs to be met for the actions to be executed (OPTIONAL).
     */
    condition?: BoolExpression;
    /**
     * The rule priority expression where 0 is the highest and less than 0 is ignored
     */
    priority?: NumberExpression;
    /**
     * A value indicating whether rule should only run once per unique set of memory paths
     */
    runOnce?: boolean;
}



/**
 * Actions triggered when a system event is emitted or the dialog is called from another dialog. Dialogs with system intents cannot be deleted.
 */
export interface OnSystemDialogBegin extends TriggerBase
{
}



/**
 * Concrete implementation for &lt;see cref="TriggerBase"/&gt; (supports all leaf nodes being sealed).
 */
export interface OnCondition extends TriggerBase
{
    readonly $kind: BotElementKind.OnCondition;
}

/**
 * Creates a `OnCondition` object with the given arguments
 */
export const makeOnCondition = (value: OmitPartial<OnCondition, '$kind', 'actions' | 'diagnostics'>): OnCondition => ({
    $kind: BotElementKind.OnCondition,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a dialog event is emitted
 */
export interface OnDialogEventBase extends TriggerBase
{
    /**
     * The event to fire on
     */
    event?: string;
}



/**
 * Concrete implementation for &lt;see cref="OnDialogEventBase" /&gt; (supports all leaf nodes being sealed).
 */
export interface OnDialogEvent extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnDialogEvent;
}

/**
 * Creates a `OnDialogEvent` object with the given arguments
 */
export const makeOnDialogEvent = (value: OmitPartial<OnDialogEvent, '$kind', 'actions' | 'diagnostics'>): OnDialogEvent => ({
    $kind: BotElementKind.OnDialogEvent,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a Activity of a given type is received
 */
export interface OnActivityBase extends OnDialogEventBase
{
    /**
     * The ActivityType which must be matched for this to trigger
     */
    type?: string;
}



/**
 * Concrete implementation for &lt;see cref="OnActivityBase" /&gt; (supports all leaf nodes being sealed).
 */
export interface OnActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnActivity;
}

/**
 * Creates a `OnActivity` object with the given arguments
 */
export const makeOnActivity = (value: OmitPartial<OnActivity, '$kind', 'actions' | 'diagnostics'>): OnActivity => ({
    $kind: BotElementKind.OnActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a Command activity is received
 */
export interface OnCommandActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnCommandActivity;
}

/**
 * Creates a `OnCommandActivity` object with the given arguments
 */
export const makeOnCommandActivity = (value: OmitPartial<OnCommandActivity, '$kind', 'actions' | 'diagnostics'>): OnCommandActivity => ({
    $kind: BotElementKind.OnCommandActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an CommandResult activity is received
 */
export interface OnCommandResultActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnCommandResultActivity;
}

/**
 * Creates a `OnCommandResultActivity` object with the given arguments
 */
export const makeOnCommandResultActivity = (value: OmitPartial<OnCommandResultActivity, '$kind', 'actions' | 'diagnostics'>): OnCommandResultActivity => ({
    $kind: BotElementKind.OnCommandResultActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when ConversationUpdateActivity is received
 */
export interface OnConversationUpdateActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnConversationUpdateActivity;
}

/**
 * Creates a `OnConversationUpdateActivity` object with the given arguments
 */
export const makeOnConversationUpdateActivity = (value: OmitPartial<OnConversationUpdateActivity, '$kind', 'actions' | 'diagnostics'>): OnConversationUpdateActivity => ({
    $kind: BotElementKind.OnConversationUpdateActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when EndOfConversationActivity is received
 */
export interface OnEndOfConversationActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnEndOfConversationActivity;
}

/**
 * Creates a `OnEndOfConversationActivity` object with the given arguments
 */
export const makeOnEndOfConversationActivity = (value: OmitPartial<OnEndOfConversationActivity, '$kind', 'actions' | 'diagnostics'>): OnEndOfConversationActivity => ({
    $kind: BotElementKind.OnEndOfConversationActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an EventActivity is received
 */
export interface OnEventActivityBase extends OnActivityBase
{
}



/**
 * Concrete implementation for &lt;see cref="OnEventActivityBase" /&gt; (supports all leaf nodes being sealed).
 */
export interface OnEventActivity extends OnEventActivityBase
{
    readonly $kind: BotElementKind.OnEventActivity;
}

/**
 * Creates a `OnEventActivity` object with the given arguments
 */
export const makeOnEventActivity = (value: OmitPartial<OnEventActivity, '$kind', 'actions' | 'diagnostics'>): OnEventActivity => ({
    $kind: BotElementKind.OnEventActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Action triggered when a conversation continues
 */
export interface OnContinueConversation extends OnEventActivityBase
{
    readonly $kind: BotElementKind.OnContinueConversation;
}

/**
 * Creates a `OnContinueConversation` object with the given arguments
 */
export const makeOnContinueConversation = (value: OmitPartial<OnContinueConversation, '$kind', 'actions' | 'diagnostics'>): OnContinueConversation => ({
    $kind: BotElementKind.OnContinueConversation,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a HandoffActivity is received
 */
export interface OnHandoffActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnHandoffActivity;
}

/**
 * Creates a `OnHandoffActivity` object with the given arguments
 */
export const makeOnHandoffActivity = (value: OmitPartial<OnHandoffActivity, '$kind', 'actions' | 'diagnostics'>): OnHandoffActivity => ({
    $kind: BotElementKind.OnHandoffActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a InstallationUpdateActivity is received
 */
export interface OnInstallationUpdateActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnInstallationUpdateActivity;
}

/**
 * Creates a `OnInstallationUpdateActivity` object with the given arguments
 */
export const makeOnInstallationUpdateActivity = (value: OmitPartial<OnInstallationUpdateActivity, '$kind', 'actions' | 'diagnostics'>): OnInstallationUpdateActivity => ({
    $kind: BotElementKind.OnInstallationUpdateActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an InvokeActivity is received
 */
export interface OnInvokeActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnInvokeActivity;
}

/**
 * Creates a `OnInvokeActivity` object with the given arguments
 */
export const makeOnInvokeActivity = (value: OmitPartial<OnInvokeActivity, '$kind', 'actions' | 'diagnostics'>): OnInvokeActivity => ({
    $kind: BotElementKind.OnInvokeActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an MessageActivity is received
 */
export interface OnMessageActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnMessageActivity;
}

/**
 * Creates a `OnMessageActivity` object with the given arguments
 */
export const makeOnMessageActivity = (value: OmitPartial<OnMessageActivity, '$kind', 'actions' | 'diagnostics'>): OnMessageActivity => ({
    $kind: BotElementKind.OnMessageActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a MessageDeleteActivity is received
 */
export interface OnMessageDeleteActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnMessageDeleteActivity;
}

/**
 * Creates a `OnMessageDeleteActivity` object with the given arguments
 */
export const makeOnMessageDeleteActivity = (value: OmitPartial<OnMessageDeleteActivity, '$kind', 'actions' | 'diagnostics'>): OnMessageDeleteActivity => ({
    $kind: BotElementKind.OnMessageDeleteActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a MessageReactionActivity is received
 */
export interface OnMessageReactionActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnMessageReactionActivity;
}

/**
 * Creates a `OnMessageReactionActivity` object with the given arguments
 */
export const makeOnMessageReactionActivity = (value: OmitPartial<OnMessageReactionActivity, '$kind', 'actions' | 'diagnostics'>): OnMessageReactionActivity => ({
    $kind: BotElementKind.OnMessageReactionActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a MessageUpdateActivity is received
 */
export interface OnMessageUpdateActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnMessageUpdateActivity;
}

/**
 * Creates a `OnMessageUpdateActivity` object with the given arguments
 */
export const makeOnMessageUpdateActivity = (value: OmitPartial<OnMessageUpdateActivity, '$kind', 'actions' | 'diagnostics'>): OnMessageUpdateActivity => ({
    $kind: BotElementKind.OnMessageUpdateActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a TypingActivity is received
 */
export interface OnTypingActivity extends OnActivityBase
{
    readonly $kind: BotElementKind.OnTypingActivity;
}

/**
 * Creates a `OnTypingActivity` object with the given arguments
 */
export const makeOnTypingActivity = (value: OmitPartial<OnTypingActivity, '$kind', 'actions' | 'diagnostics'>): OnTypingActivity => ({
    $kind: BotElementKind.OnTypingActivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Triggered to assign an entity to a property
 */
export interface OnAssignEntity extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnAssignEntity;
    /**
     * The property filter on events
     */
    property?: string;
    /**
     * The value filter on events
     */
    value?: string;
    /**
     * The operation filter on events
     */
    operation?: string;
}

/**
 * Creates a `OnAssignEntity` object with the given arguments
 */
export const makeOnAssignEntity = (value: OmitPartial<OnAssignEntity, '$kind', 'actions' | 'diagnostics'>): OnAssignEntity => ({
    $kind: BotElementKind.OnAssignEntity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a dialog is started via BeginDialog()
 */
export interface OnBeginDialog extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnBeginDialog;
}

/**
 * Creates a `OnBeginDialog` object with the given arguments
 */
export const makeOnBeginDialog = (value: OmitPartial<OnBeginDialog, '$kind', 'actions' | 'diagnostics'>): OnBeginDialog => ({
    $kind: BotElementKind.OnBeginDialog,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an dialog was canceled
 */
export interface OnCancelDialog extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnCancelDialog;
}

/**
 * Creates a `OnCancelDialog` object with the given arguments
 */
export const makeOnCancelDialog = (value: OmitPartial<OnCancelDialog, '$kind', 'actions' | 'diagnostics'>): OnCancelDialog => ({
    $kind: BotElementKind.OnCancelDialog,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Triggered to choose between different possible entity resolutions
 */
export interface OnChooseEntity extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnChooseEntity;
    /**
     * Operation filter on event
     */
    operation?: string;
    /**
     * The property filter on event
     */
    property?: string;
    /**
     * The value filter on event
     */
    value?: string;
}

/**
 * Creates a `OnChooseEntity` object with the given arguments
 */
export const makeOnChooseEntity = (value: OmitPartial<OnChooseEntity, '$kind', 'actions' | 'diagnostics'>): OnChooseEntity => ({
    $kind: BotElementKind.OnChooseEntity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Triggered to choose which property an entity goes to
 */
export interface OnChooseProperty extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnChooseProperty;
}

/**
 * Creates a `OnChooseProperty` object with the given arguments
 */
export const makeOnChooseProperty = (value: OmitPartial<OnChooseProperty, '$kind', 'actions' | 'diagnostics'>): OnChooseProperty => ({
    $kind: BotElementKind.OnChooseProperty,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Triggered when all actions and ambiguity events have been processed
 */
export interface OnEndOfActions extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnEndOfActions;
}

/**
 * Creates a `OnEndOfActions` object with the given arguments
 */
export const makeOnEndOfActions = (value: OmitPartial<OnEndOfActions, '$kind', 'actions' | 'diagnostics'>): OnEndOfActions => ({
    $kind: BotElementKind.OnEndOfActions,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an error event has been emitted
 */
export interface OnError extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnError;
}

/**
 * Creates a `OnError` object with the given arguments
 */
export const makeOnError = (value: OmitPartial<OnError, '$kind', 'actions' | 'diagnostics'>): OnError => ({
    $kind: BotElementKind.OnError,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * The intent trigger that should be used in Pva v2.0
 */
export interface OnRecognizedIntentBase extends TriggerBase
{
    /**
     * Intent to match on
     */
    intent?: Intent;
}



export interface OnRecognizedIntent extends OnRecognizedIntentBase
{
    readonly $kind: BotElementKind.OnRecognizedIntent;
}

/**
 * Creates a `OnRecognizedIntent` object with the given arguments
 */
export const makeOnRecognizedIntent = (value: OmitPartial<OnRecognizedIntent, '$kind', 'actions' | 'diagnostics'>): OnRecognizedIntent => ({
    $kind: BotElementKind.OnRecognizedIntent,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Used for deserializing of existing adaptive dialogs. Actions triggered when an Activity has been received and the recognized intents and entities match specified list of intent and entity filters
 */
export interface OnIntentBase extends OnDialogEventBase
{
    /**
     * Intent id to match on
     */
    intent?: string;
}



/**
 * Concrete implementation for &lt;see cref="OnIntentBase" /&gt; (supports all leaf nodes being sealed).
 */
export interface OnIntent extends OnIntentBase
{
    readonly $kind: BotElementKind.OnIntent;
}

/**
 * Creates a `OnIntent` object with the given arguments
 */
export const makeOnIntent = (value: OmitPartial<OnIntent, '$kind', 'actions' | 'diagnostics'>): OnIntent => ({
    $kind: BotElementKind.OnIntent,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an Intent of "ChooseIntent" has been emitted by a recognizer
 */
export interface OnChooseIntent extends OnIntentBase
{
    readonly $kind: BotElementKind.OnChooseIntent;
    /**
     * The list of intent names that must be in the chooseIntent to match
     */
    intents: string[];
}

/**
 * Creates a `OnChooseIntent` object with the given arguments
 */
export const makeOnChooseIntent = (value: OmitPartial<OnChooseIntent, '$kind', 'actions' | 'intents' | 'diagnostics'>): OnChooseIntent => ({
    $kind: BotElementKind.OnChooseIntent,
    actions: [],
    intents: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when an RepromptDialog event is emitted
 */
export interface OnRepromptDialog extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnRepromptDialog;
}

/**
 * Creates a `OnRepromptDialog` object with the given arguments
 */
export const makeOnRepromptDialog = (value: OmitPartial<OnRepromptDialog, '$kind', 'actions' | 'diagnostics'>): OnRepromptDialog => ({
    $kind: BotElementKind.OnRepromptDialog,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Actions triggered when a UnknownIntent event has been emitted by the recognizer
 */
export interface OnUnknownIntent extends OnDialogEventBase
{
    readonly $kind: BotElementKind.OnUnknownIntent;
}

/**
 * Creates a `OnUnknownIntent` object with the given arguments
 */
export const makeOnUnknownIntent = (value: OmitPartial<OnUnknownIntent, '$kind', 'actions' | 'diagnostics'>): OnUnknownIntent => ({
    $kind: BotElementKind.OnUnknownIntent,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the Greeting system dialog.
 */
export interface OnGreeting extends OnRecognizedIntentBase
{
    readonly $kind: BotElementKind.OnGreeting;
    /**
     * When enabled, causes the bot to ignore the ConversationUpdate activity in the DirectLine channel and wait for a StartConversation event to trigger the greeting.
     */
    legacyConversationStartBehavior?: boolean | null;
}

/**
 * Creates a `OnGreeting` object with the given arguments
 */
export const makeOnGreeting = (value: OmitPartial<OnGreeting, '$kind', 'actions' | 'diagnostics'>): OnGreeting => ({
    $kind: BotElementKind.OnGreeting,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the Talk to Agent system dialog.
 */
export interface OnTalkToAgent extends OnRecognizedIntentBase
{
    readonly $kind: BotElementKind.OnTalkToAgent;
}

/**
 * Creates a `OnTalkToAgent` object with the given arguments
 */
export const makeOnTalkToAgent = (value: OmitPartial<OnTalkToAgent, '$kind', 'actions' | 'diagnostics'>): OnTalkToAgent => ({
    $kind: BotElementKind.OnTalkToAgent,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the Goodbye system dialog. Engine flushes the existing context and executes the dialog.
 */
export interface OnStartOver extends OnRecognizedIntentBase
{
    readonly $kind: BotElementKind.OnStartOver;
}

/**
 * Creates a `OnStartOver` object with the given arguments
 */
export const makeOnStartOver = (value: OmitPartial<OnStartOver, '$kind', 'actions' | 'diagnostics'>): OnStartOver => ({
    $kind: BotElementKind.OnStartOver,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the Goodbye system dialog.
 */
export interface OnGoodbye extends OnRecognizedIntentBase
{
    readonly $kind: BotElementKind.OnGoodbye;
}

/**
 * Creates a `OnGoodbye` object with the given arguments
 */
export const makeOnGoodbye = (value: OmitPartial<OnGoodbye, '$kind', 'actions' | 'diagnostics'>): OnGoodbye => ({
    $kind: BotElementKind.OnGoodbye,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the Thankyou system dialog.
 */
export interface OnThankYou extends OnRecognizedIntentBase
{
    readonly $kind: BotElementKind.OnThankYou;
}

/**
 * Creates a `OnThankYou` object with the given arguments
 */
export const makeOnThankYou = (value: OmitPartial<OnThankYou, '$kind', 'actions' | 'diagnostics'>): OnThankYou => ({
    $kind: BotElementKind.OnThankYou,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the End of conversation system dialog.
 */
export interface OnEndOfConversation extends OnSystemDialogBegin
{
    readonly $kind: BotElementKind.OnEndOfConversation;
}

/**
 * Creates a `OnEndOfConversation` object with the given arguments
 */
export const makeOnEndOfConversation = (value: OmitPartial<OnEndOfConversation, '$kind', 'actions' | 'diagnostics'>): OnEndOfConversation => ({
    $kind: BotElementKind.OnEndOfConversation,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the end of the dialog when Bot assumes that the problem is resolved.
 */
export interface OnAssumedSuccess extends OnSystemDialogBegin
{
    readonly $kind: BotElementKind.OnAssumedSuccess;
}

/**
 * Creates a `OnAssumedSuccess` object with the given arguments
 */
export const makeOnAssumedSuccess = (value: OmitPartial<OnAssumedSuccess, '$kind', 'actions' | 'diagnostics'>): OnAssumedSuccess => ({
    $kind: BotElementKind.OnAssumedSuccess,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the end of the dialog when the conversation is handed over to a human agent.
 */
export interface OnConfirmedFailure extends OnSystemDialogBegin
{
    readonly $kind: BotElementKind.OnConfirmedFailure;
}

/**
 * Creates a `OnConfirmedFailure` object with the given arguments
 */
export const makeOnConfirmedFailure = (value: OmitPartial<OnConfirmedFailure, '$kind', 'actions' | 'diagnostics'>): OnConfirmedFailure => ({
    $kind: BotElementKind.OnConfirmedFailure,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles situations when the user confirmed that Bot resolved their problem.
 */
export interface OnConfirmedSuccess extends OnSystemDialogBegin
{
    readonly $kind: BotElementKind.OnConfirmedSuccess;
}

/**
 * Creates a `OnConfirmedSuccess` object with the given arguments
 */
export const makeOnConfirmedSuccess = (value: OmitPartial<OnConfirmedSuccess, '$kind', 'actions' | 'diagnostics'>): OnConfirmedSuccess => ({
    $kind: BotElementKind.OnConfirmedSuccess,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that is invoked when no user input has been received during a specified duration of time
 */
export interface OnInactivity extends TriggerBase
{
    readonly $kind: BotElementKind.OnInactivity;
    /**
     * Inactivity duration in seconds after which the trigger will be invoked
     */
    durationInSeconds: NumberExpression;
}

/**
 * Creates a `OnInactivity` object with the given arguments
 */
export const makeOnInactivity = (value: OmitPartial<OnInactivity, '$kind', 'actions' | 'diagnostics'>): OnInactivity => ({
    $kind: BotElementKind.OnInactivity,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Trigger that handles the Fallback logic when a user query matches no other intents.
 */
export interface OnFallback extends OnSystemDialogBegin
{
    readonly $kind: BotElementKind.OnFallback;
}

/**
 * Creates a `OnFallback` object with the given arguments
 */
export const makeOnFallback = (value: OmitPartial<OnFallback, '$kind', 'actions' | 'diagnostics'>): OnFallback => ({
    $kind: BotElementKind.OnFallback,
    actions: [],
    diagnostics: [],
    ...value
});


export interface ActionReference extends BotElement
{
    readonly $kind: BotElementKind.ActionReference;
    triggerId: TriggerId;
    actionId: ActionId;
}

/**
 * Creates a `ActionReference` object with the given arguments
 */
export const makeActionReference = (value: OmitPartial<ActionReference, '$kind', 'diagnostics'>): ActionReference => ({
    $kind: BotElementKind.ActionReference,
    diagnostics: [],
    ...value
});


export interface VariableBase extends BotElement
{
    /**
     * Unique name for the variable. For global variables, this means unique within the bot.                    For dialog variables, this means unique within the dialog. If the name of an input or                    output property is used, this means we are setting the initializer of a variable that                    is also an input/output.
     */
    name: string;
    /**
     * The scope of the variable.
     */
    scope?: VariableScope;
    /**
     * If true, this variable can be set directly from external sources, such as ChannelData and integrations with OmniChannel.
     */
    isExternalInitializationAllowed?: boolean | null;
}



/**
 * Representation of a variable that is stored in its own Dataverse component.
 */
export interface StandaloneVariable extends VariableBase
{
    readonly $kind: BotElementKind.StandaloneVariable;
    defaultValue: ValueExpression;
}

/**
 * Creates a `StandaloneVariable` object with the given arguments
 */
export const makeStandaloneVariable = (value: OmitPartial<StandaloneVariable, '$kind', 'diagnostics'>): StandaloneVariable => ({
    $kind: BotElementKind.StandaloneVariable,
    diagnostics: [],
    ...value
});


/**
 * Represents a variable with an initializer and a particular lifetime bound inside a dialog
 */
export interface Variable extends VariableBase
{
    readonly $kind: BotElementKind.Variable;
    /**
     * Initializer for this variable.
     */
    initializer?: VariableInitializer;
}

/**
 * Creates a `Variable` object with the given arguments
 */
export const makeVariable = (value: OmitPartial<Variable, '$kind', 'diagnostics'>): Variable => ({
    $kind: BotElementKind.Variable,
    diagnostics: [],
    ...value
});


/**
 * Describes a way for a value to be provided to a variable when it's missing.
 */
export interface VariableInitializer extends BotElement
{
}



/**
 * The initializer that initializes the variable via an action in the dialog.
 */
export interface ActionInitializer extends VariableInitializer
{
    readonly $kind: BotElementKind.ActionInitializer;
    /**
     * The reference to the action that initializes the variable.
     */
    action: ActionReference;
}

/**
 * Creates a `ActionInitializer` object with the given arguments
 */
export const makeActionInitializer = (value: OmitPartial<ActionInitializer, '$kind', 'diagnostics'>): ActionInitializer => ({
    $kind: BotElementKind.ActionInitializer,
    diagnostics: [],
    ...value
});


/**
 * The initializer that initializes the variable via an action in the dialog.
 */
export interface ExpressionInitializer extends VariableInitializer
{
    readonly $kind: BotElementKind.ExpressionInitializer;
    /**
     * The default value for this variable.
     */
    value: ValueExpression;
}

/**
 * Creates a `ExpressionInitializer` object with the given arguments
 */
export const makeExpressionInitializer = (value: OmitPartial<ExpressionInitializer, '$kind', 'diagnostics'>): ExpressionInitializer => ({
    $kind: BotElementKind.ExpressionInitializer,
    diagnostics: [],
    ...value
});


/**
 * Unique identifier for a dialog definition.
 */
export interface Dialog extends BotElement
{
    /**
     * Unique identifier for a dialog.
     */
    id?: DialogSchemaName;
}



/**
 * The Adaptive Dialog models conversation using events and events to adapt dynamicaly to changing conversation flow
 */
export interface AdaptiveDialog extends Dialog
{
    readonly $kind: BotElementKind.AdaptiveDialog;
    /**
     * Recognizer for processing incoming user input
     */
    recognizer?: Recognizer;
    /**
     * Trigger handlers to respond to conditions which modifying the executing plan
     */
    triggers: TriggerBase[];
    /**
     * An expression indicating whether to end the dialog when there are no actions to execute
     */
    autoEndDialog?: BoolExpression;
    /**
     * The property to return as the result when the dialog ends when there are no more Actions and AutoEndDialog = true
     */
    defaultResultProperty?: PropertyPath;
    /**
     * The bot level (global) trigger of this adaptive dialog. Having OnBeginDialog trigger means that the dialog can only be invoked by other dialogs.
     */
    beginDialog?: TriggerBase;
    /**
     * Input data contract for this dialog. Users will be able to see and use variables that are defined by RecordDataType in any branch of the dialog. It's also possible to set an initializer for this variable via AdaptiveDialog.Variables property.
     */
    inputType?: RecordDataType;
    /**
     * Output data contract for this dialog. Variables that match the keys of the output RecordDataType will be returned.
     */
    outputType?: RecordDataType;
    /**
     * List of variables with initializers.
     */
    variables: Variable[];
    /**
     * Whether this dialog is disabled
     */
    disabled?: boolean | null;
    /**
     * Contains the required metadata for V1 -> V2 content conversion
     */
    conversionMetadata?: ConversionMetadata;
}

/**
 * Creates a `AdaptiveDialog` object with the given arguments
 */
export const makeAdaptiveDialog = (value?: OmitPartial<AdaptiveDialog, '$kind', 'triggers' | 'variables' | 'diagnostics'>): AdaptiveDialog => ({
    $kind: BotElementKind.AdaptiveDialog,
    triggers: [],
    variables: [],
    diagnostics: [],
    ...value
});


/**
 * Class containing all the properties required to support V1 -> V2 content conversion
 */
export interface ConversionMetadata
{
    /**
     * Maps legacy ids of the variables initialized or used in this dialog to the their names
     */
    variableIdToNameMapping: Dictionary<string>;
    /**
     * Maps legacy ids of the variables initialized in this dialog to theirs types.
     */
    initializedVariableIdToTypeMapping: Dictionary<DataType>;
}



/**
 * Any individual Action within a dialog flow designer.
 */
export interface DialogAction extends BotElement
{
    /**
     * Unique identifier for an action.
     */
    id: ActionId;
    /**
     * Whether this action should be disabled
     */
    disabled?: boolean | null;
    /**
     * Sets the outcome of the current session for the purpose of analytics. The outcome is set before the action's execution.
     */
    conversationOutcome?: ConversationOutcome;
}



/**
 * An abstract class for all actions that take and return some objects. Examples: flows, skills. Actions should be typed, for every action we will know an input and output RecordDataType.
 */
export interface ExternalAction extends DialogAction
{
    /**
     * Input of the action
     */
    input?: ActionInputBinding;
    /**
     * Output of the action
     */
    output?: ActionOutputBinding;
}



/**
 * The action to invoke the flow with the list of arguments and assignment of results to variables.
 */
export interface InvokeFlowAction extends ExternalAction
{
    readonly $kind: BotElementKind.InvokeFlowAction;
    /**
     * The id of the flow to invoke. Flow id stays the same across the environments.
     */
    flowId: FlowId;
}

/**
 * Creates a `InvokeFlowAction` object with the given arguments
 */
export const makeInvokeFlowAction = (value: OmitPartial<InvokeFlowAction, '$kind' | 'id', 'diagnostics'>): InvokeFlowAction => ({
    $kind: BotElementKind.InvokeFlowAction,
    id: `invokeFlowAction_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * The action to invoke the skill with the list of arguments and assignment of results to variables.
 */
export interface InvokeSkillAction extends ExternalAction
{
    readonly $kind: BotElementKind.InvokeSkillAction;
    /**
     * The id of the skill to invoke. This id corresponds to the SchemaName of the BotComponent containing the skill.
     */
    skillId: SkillSchemaName;
    /**
     * The id of the action within the skill to invoke.
     */
    actionId: SkillActionId;
}

/**
 * Creates a `InvokeSkillAction` object with the given arguments
 */
export const makeInvokeSkillAction = (value: OmitPartial<InvokeSkillAction, '$kind' | 'id', 'diagnostics'>): InvokeSkillAction => ({
    $kind: BotElementKind.InvokeSkillAction,
    id: `invokeSkillAction_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Defines input dialogs
 */
export interface InputDialog extends DialogAction
{
    /**
     * Indicate what happens when the variable, where the response is saved to, already has a value
     */
    alwaysPrompt?: BoolExpression;
    /**
     * Intteruption policy
     */
    allowInterruptions?: BoolExpression;
    /**
     * The variable into which the response will be saved
     */
    property: PropertyPath;
    /**
     * A the expression to use to bind input to the dialog
     */
    value?: ValueExpression;
    /**
     * The activity to send to the user
     */
    prompt: ActivityTemplateBase;
    /**
     * The activity template for retrying
     */
    unrecognizedPrompt?: ActivityTemplateBase;
    /**
     * The activity template to send to the user whenever the value provided is invalid
     */
    invalidPrompt?: ActivityTemplateBase;
    /**
     * The activity template to send when MaxTurnCount has been reached and the default value is used
     */
    defaultValueResponse?: ActivityTemplateBase;
    /**
     * The expressions to run to validate the input
     */
    validations: BoolExpression[];
    /**
     * Maximum number of times to ask the user when they provide an invalid response
     */
    maxTurnCount?: IntExpression;
    /**
     * The default value for the input dialog when MaxTurnCount is exceeded
     */
    defaultValue?: ValueExpression;
}



export interface Question extends InputDialog
{
    readonly $kind: BotElementKind.Question;
    entity: EntityReference;
}

/**
 * Creates a `Question` object with the given arguments
 */
export const makeQuestion = (value: OmitPartial<Question, '$kind' | 'id', 'validations' | 'diagnostics'>): Question => ({
    $kind: BotElementKind.Question,
    id: `question_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * Action that asks customer to give a star (from 1 to 5) to the bot. CSAT stands for customer satisfaction score
 */
export interface CSATQuestion extends DialogAction
{
    readonly $kind: BotElementKind.CSATQuestion;
}

/**
 * Creates a `CSATQuestion` object with the given arguments
 */
export const makeCSATQuestion = (value?: OmitPartial<CSATQuestion, '$kind' | 'id', 'diagnostics'>): CSATQuestion => ({
    $kind: BotElementKind.CSATQuestion,
    id: `cSATQuestion_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Input dialog which prompts the user to send a file
 */
export interface AttachmentInput extends InputDialog
{
    readonly $kind: BotElementKind.AttachmentInput;
    /**
     * The AttachmentOutputFormat for the attachments
     */
    outputFormat?: EnumExpression<AttachmentOutputFormat>;
}

/**
 * Creates a `AttachmentInput` object with the given arguments
 */
export const makeAttachmentInput = (value: OmitPartial<AttachmentInput, '$kind' | 'id', 'validations' | 'diagnostics'>): AttachmentInput => ({
    $kind: BotElementKind.AttachmentInput,
    id: `attachmentInput_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * ChoiceInput - Declarative input to gather choices from user
 */
export interface ChoiceInput extends InputDialog
{
    readonly $kind: BotElementKind.ChoiceInput;
    /**
     * List of choices to present to user
     */
    choices?: ArrayExpression<Choice>;
    /**
     * ListStyle to use to render the choices
     */
    style?: EnumExpression<ListStyle>;
    /**
     * The DefaultLocale to use to parse confirmation choices if there is not one passed by the caller
     */
    defaultLocale?: StringExpression;
    /**
     * The format of the response (value or the index of the choice)
     */
    outputFormat?: EnumExpression<ChoiceOutputFormat>;
    /**
     * ChoiceOptions controls display options for customizing language
     */
    choiceOptions?: ObjectExpression<ChoiceFactoryOptions>;
    /**
     * How to recognize choices in the response
     */
    recognizerOptions?: ObjectExpression<FindChoicesOptions>;
}

/**
 * Creates a `ChoiceInput` object with the given arguments
 */
export const makeChoiceInput = (value: OmitPartial<ChoiceInput, '$kind' | 'id', 'validations' | 'diagnostics'>): ChoiceInput => ({
    $kind: BotElementKind.ChoiceInput,
    id: `choiceInput_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * Declarative input control that will gather yes/no confirmation input from a set of choices
 */
export interface ConfirmInput extends InputDialog
{
    readonly $kind: BotElementKind.ConfirmInput;
    /**
     * The DefaultLocale to use to parse confirmation choices if there is not one passed by the caller
     */
    defaultLocale?: StringExpression;
    /**
     * The ListType to use to prompt the user
     */
    style?: EnumExpression<ListStyle>;
    /**
     * The ChoiceOptions to use to format presenting confirmation choices to the user
     */
    choiceOptions?: ObjectExpression<ChoiceFactoryOptions>;
    /**
     * The Choices to present
     */
    confirmChoices?: ArrayExpression<Choice>;
    /**
     * The expression to use to format the result
     */
    outputFormat?: ValueExpression;
}

/**
 * Creates a `ConfirmInput` object with the given arguments
 */
export const makeConfirmInput = (value: OmitPartial<ConfirmInput, '$kind' | 'id', 'validations' | 'diagnostics'>): ConfirmInput => ({
    $kind: BotElementKind.ConfirmInput,
    id: `confirmInput_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * Input dialog to collect a datetime from the user
 */
export interface DateTimeInput extends InputDialog
{
    readonly $kind: BotElementKind.DateTimeInput;
    /**
     * The DefaultLocale to use to parse confirmation choices if there is not one passed by the caller
     */
    defaultLocale?: StringExpression;
    /**
     * The expression to use to format the result
     */
    outputFormat?: ValueExpression;
}

/**
 * Creates a `DateTimeInput` object with the given arguments
 */
export const makeDateTimeInput = (value: OmitPartial<DateTimeInput, '$kind' | 'id', 'validations' | 'diagnostics'>): DateTimeInput => ({
    $kind: BotElementKind.DateTimeInput,
    id: `dateTimeInput_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * Input dialog for asking for numbers
 */
export interface NumberInput extends InputDialog
{
    readonly $kind: BotElementKind.NumberInput;
    /**
     * The DefaultLocale to use to parse confirmation choices if there is not one passed by the caller
     */
    defaultLocale?: StringExpression;
    /**
     * The format of the response (value or the index of the choice)
     */
    outputFormat?: NumberExpression;
}

/**
 * Creates a `NumberInput` object with the given arguments
 */
export const makeNumberInput = (value: OmitPartial<NumberInput, '$kind' | 'id', 'validations' | 'diagnostics'>): NumberInput => ({
    $kind: BotElementKind.NumberInput,
    id: `numberInput_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * OAuthInput prompts user to login
 */
export interface OAuthInput extends DialogAction
{
    readonly $kind: BotElementKind.OAuthInput;
    /**
     * The title of the sign-in card
     */
    title?: StringExpression;
    /**
     * Any additional text to include in the sign-in card
     */
    text?: StringExpression;
}

/**
 * Creates a `OAuthInput` object with the given arguments
 */
export const makeOAuthInput = (value?: OmitPartial<OAuthInput, '$kind' | 'id', 'diagnostics'>): OAuthInput => ({
    $kind: BotElementKind.OAuthInput,
    id: `oAuthInput_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Declarative text input to gather text data from users
 */
export interface TextInput extends InputDialog
{
    readonly $kind: BotElementKind.TextInput;
    /**
     * The expression to use to format the result
     */
    outputFormat?: StringExpression;
}

/**
 * Creates a `TextInput` object with the given arguments
 */
export const makeTextInput = (value: OmitPartial<TextInput, '$kind' | 'id', 'validations' | 'diagnostics'>): TextInput => ({
    $kind: BotElementKind.TextInput,
    id: `textInput_${generateDesignerId()}`,
    validations: [],
    diagnostics: [],
    ...value
});


/**
 * ActionScope manages execution of a block of actions, and supports Goto, Continue and Break semantics
 */
export interface ActionScopeBase extends DialogAction
{
    /**
     * The actions to execute
     */
    actions: DialogAction[];
}



/**
 * Used to provide implicitly created action scope properties.
 */
export interface ActionScope extends ActionScopeBase
{
    readonly $kind: BotElementKind.ActionScope;
}

/**
 * Creates a `ActionScope` object with the given arguments
 */
export const makeActionScope = (value?: OmitPartial<ActionScope, '$kind' | 'id', 'actions' | 'diagnostics'>): ActionScope => ({
    $kind: BotElementKind.ActionScope,
    id: `actionScope_${generateDesignerId()}`,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Cases of action scope
 */
export interface Case extends ActionScopeBase
{
    readonly $kind: BotElementKind.Case;
    /**
     * Constant to be compared against condition
     */
    value: string;
}

/**
 * Creates a `Case` object with the given arguments
 */
export const makeCase = (value: OmitPartial<Case, '$kind' | 'id', 'actions' | 'diagnostics'>): Case => ({
    $kind: BotElementKind.Case,
    id: `case_${generateDesignerId()}`,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Executes a set of actions once for each item in an in-memory list or collection
 */
export interface Foreach extends ActionScopeBase
{
    readonly $kind: BotElementKind.Foreach;
    /**
     * Property path expression to the collection of items
     */
    itemsProperty: ValueExpression;
    /**
     * Property path expression to item index
     */
    index?: PropertyPath;
    /**
     * Property path expression to item value
     */
    value?: PropertyPath;
}

/**
 * Creates a `Foreach` object with the given arguments
 */
export const makeForeach = (value: OmitPartial<Foreach, '$kind' | 'id', 'actions' | 'diagnostics'>): Foreach => ({
    $kind: BotElementKind.Foreach,
    id: `foreach_${generateDesignerId()}`,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Executes a set of actions once for each item in an in-memory list or collection
 */
export interface ForeachPage extends ActionScopeBase
{
    readonly $kind: BotElementKind.ForeachPage;
    /**
     * The item properties list
     */
    itemsProperty?: ValueExpression;
    /**
     * The pages list
     */
    page?: StringExpression;
    /**
     * The page indexes list
     */
    pageIndex?: StringExpression;
    /**
     * The page size
     */
    pageSize?: IntExpression;
}

/**
 * Creates a `ForeachPage` object with the given arguments
 */
export const makeForeachPage = (value?: OmitPartial<ForeachPage, '$kind' | 'id', 'actions' | 'diagnostics'>): ForeachPage => ({
    $kind: BotElementKind.ForeachPage,
    id: `foreachPage_${generateDesignerId()}`,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Action which calls another dialog
 */
export interface BaseInvokeDialogOrSelf extends DialogAction
{
    /**
     * Input of the dialog to call.
     */
    input?: ActionInputBinding;
    /**
     * A value indicating whether to have the new dialog should process the activity
     */
    activityProcessed?: BoolExpression;
}



/**
 * Action which calls another dialog
 */
export interface BaseInvokeDialog extends BaseInvokeDialogOrSelf
{
    /**
     * The dialog to call
     */
    dialog: DialogExpression;
}



/**
 * Action which begins executing another dialog, when it is done, it will return to the caller
 */
export interface BeginDialog extends BaseInvokeDialog
{
    readonly $kind: BotElementKind.BeginDialog;
    /**
     * The property path to store the entire dialog result in.
     */
    resultProperty?: StringExpression;
    /**
     * Output of the action
     */
    output?: ActionOutputBinding;
}

/**
 * Creates a `BeginDialog` object with the given arguments
 */
export const makeBeginDialog = (value: OmitPartial<BeginDialog, '$kind' | 'id', 'diagnostics'>): BeginDialog => ({
    $kind: BotElementKind.BeginDialog,
    id: `beginDialog_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Action which repeats the active dialog (restarting it)
 */
export interface RepeatDialog extends BaseInvokeDialogOrSelf
{
    readonly $kind: BotElementKind.RepeatDialog;
    /**
     * An optional expression which if is true will allow loop of the repeated dialog
     */
    allowLoop?: BoolExpression;
}

/**
 * Creates a `RepeatDialog` object with the given arguments
 */
export const makeRepeatDialog = (value?: OmitPartial<RepeatDialog, '$kind' | 'id', 'diagnostics'>): RepeatDialog => ({
    $kind: BotElementKind.RepeatDialog,
    id: `repeatDialog_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Action which calls another dialog, when it is done it will go to the callers parent dialog
 */
export interface ReplaceDialog extends BaseInvokeDialog
{
    readonly $kind: BotElementKind.ReplaceDialog;
}

/**
 * Creates a `ReplaceDialog` object with the given arguments
 */
export const makeReplaceDialog = (value: OmitPartial<ReplaceDialog, '$kind' | 'id', 'diagnostics'>): ReplaceDialog => ({
    $kind: BotElementKind.ReplaceDialog,
    id: `replaceDialog_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Break out of a loop
 */
export interface BreakLoop extends DialogAction
{
    readonly $kind: BotElementKind.BreakLoop;
}

/**
 * Creates a `BreakLoop` object with the given arguments
 */
export const makeBreakLoop = (value?: OmitPartial<BreakLoop, '$kind' | 'id', 'diagnostics'>): BreakLoop => ({
    $kind: BotElementKind.BreakLoop,
    id: `breakLoop_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Base class for CancelAllDialogs api
 */
export interface CancelAllDialogsBase extends DialogAction
{
    /**
     * A value indicating whether to have the calling dialog should process the activity
     */
    activityProcessed?: BoolExpression;
    /**
     * Event name
     */
    eventName?: StringExpression;
    /**
     * Value expression for EventValue
     */
    eventValue?: ValueExpression;
}



/**
 * End all of the current topics
 */
export interface CancelAllDialogs extends CancelAllDialogsBase
{
    readonly $kind: BotElementKind.CancelAllDialogs;
}

/**
 * Creates a `CancelAllDialogs` object with the given arguments
 */
export const makeCancelAllDialogs = (value?: OmitPartial<CancelAllDialogs, '$kind' | 'id', 'diagnostics'>): CancelAllDialogs => ({
    $kind: BotElementKind.CancelAllDialogs,
    id: `cancelAllDialogs_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Command to cancel all of the current dialogs by emitting an event which must be caught to prevent cancelation from propagating
 */
export interface CancelDialog extends CancelAllDialogsBase
{
    readonly $kind: BotElementKind.CancelDialog;
}

/**
 * Creates a `CancelDialog` object with the given arguments
 */
export const makeCancelDialog = (value?: OmitPartial<CancelDialog, '$kind' | 'id', 'diagnostics'>): CancelDialog => ({
    $kind: BotElementKind.CancelDialog,
    id: `cancelDialog_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Clears the state of all the variables.
 */
export interface ClearAllVariables extends DialogAction
{
    readonly $kind: BotElementKind.ClearAllVariables;
    variables?: EnumExpression<VariablesToClear>;
}

/**
 * Creates a `ClearAllVariables` object with the given arguments
 */
export const makeClearAllVariables = (value?: OmitPartial<ClearAllVariables, '$kind' | 'id', 'diagnostics'>): ClearAllVariables => ({
    $kind: BotElementKind.ClearAllVariables,
    id: `clearAllVariables_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Continue the loop
 */
export interface ContinueLoop extends DialogAction
{
    readonly $kind: BotElementKind.ContinueLoop;
}

/**
 * Creates a `ContinueLoop` object with the given arguments
 */
export const makeContinueLoop = (value?: OmitPartial<ContinueLoop, '$kind' | 'id', 'diagnostics'>): ContinueLoop => ({
    $kind: BotElementKind.ContinueLoop,
    id: `continueLoop_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Break the debug
 */
export interface DebugBreak extends DialogAction
{
    readonly $kind: BotElementKind.DebugBreak;
}

/**
 * Creates a `DebugBreak` object with the given arguments
 */
export const makeDebugBreak = (value?: OmitPartial<DebugBreak, '$kind' | 'id', 'diagnostics'>): DebugBreak => ({
    $kind: BotElementKind.DebugBreak,
    id: `debugBreak_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Send an activity back to the user
 */
export interface DeleteActivity extends DialogAction
{
    readonly $kind: BotElementKind.DeleteActivity;
    /**
     * The expression which resolves to the activityId to update
     */
    activityId?: StringExpression;
}

/**
 * Creates a `DeleteActivity` object with the given arguments
 */
export const makeDeleteActivity = (value?: OmitPartial<DeleteActivity, '$kind' | 'id', 'diagnostics'>): DeleteActivity => ({
    $kind: BotElementKind.DeleteActivity,
    id: `deleteActivity_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Deletes a property from memory
 */
export interface DeleteProperties extends DialogAction
{
    readonly $kind: BotElementKind.DeleteProperties;
    /**
     * Properties to remove
     */
    properties: PropertyPath[];
}

/**
 * Creates a `DeleteProperties` object with the given arguments
 */
export const makeDeleteProperties = (value?: OmitPartial<DeleteProperties, '$kind' | 'id', 'properties' | 'diagnostics'>): DeleteProperties => ({
    $kind: BotElementKind.DeleteProperties,
    id: `deleteProperties_${generateDesignerId()}`,
    properties: [],
    diagnostics: [],
    ...value
});


/**
 * Deletes a property from memory
 */
export interface DeleteProperty extends DialogAction
{
    readonly $kind: BotElementKind.DeleteProperty;
    /**
     * Property path to remove
     */
    property: PropertyPath;
}

/**
 * Creates a `DeleteProperty` object with the given arguments
 */
export const makeDeleteProperty = (value: OmitPartial<DeleteProperty, '$kind' | 'id', 'diagnostics'>): DeleteProperty => ({
    $kind: BotElementKind.DeleteProperty,
    id: `deleteProperty_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Lets you modify an array in memory
 */
export interface EditArray extends DialogAction
{
    readonly $kind: BotElementKind.EditArray;
    /**
     * Type of change being applied
     */
    changeType?: ArrayChangeType;
    /**
     * Property path expression to the collection of items
     */
    itemsProperty: PropertyPath;
    /**
     * The path to store the result of the action
     */
    resultProperty?: PropertyPath;
    /**
     * The expression of the value to put onto the array
     */
    value?: ValueExpression;
}

/**
 * Creates a `EditArray` object with the given arguments
 */
export const makeEditArray = (value: OmitPartial<EditArray, '$kind' | 'id', 'diagnostics'>): EditArray => ({
    $kind: BotElementKind.EditArray,
    id: `editArray_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Action which emits an event declaratively
 */
export interface EmitEvent extends DialogAction
{
    readonly $kind: BotElementKind.EmitEvent;
    /**
     * The name of the event to emit
     */
    eventName: StringExpression;
    /**
     * The memory property path to use to get the value to send as part of the event
     */
    eventValue?: ValueExpression;
    /**
     * A value indicating whether the event should bubble to parents or not
     */
    bubbleEvent?: BoolExpression;
}

/**
 * Creates a `EmitEvent` object with the given arguments
 */
export const makeEmitEvent = (value: OmitPartial<EmitEvent, '$kind' | 'id', 'diagnostics'>): EmitEvent => ({
    $kind: BotElementKind.EmitEvent,
    id: `emitEvent_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * End the current topic
 */
export interface EndDialog extends DialogAction
{
    readonly $kind: BotElementKind.EndDialog;
    /**
     * A value expression for the result to be returned to the caller
     */
    value?: ValueExpression;
}

/**
 * Creates a `EndDialog` object with the given arguments
 */
export const makeEndDialog = (value?: OmitPartial<EndDialog, '$kind' | 'id', 'diagnostics'>): EndDialog => ({
    $kind: BotElementKind.EndDialog,
    id: `endDialog_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * This command ends the current turn without ending the dialog
 */
export interface EndTurn extends DialogAction
{
    readonly $kind: BotElementKind.EndTurn;
}

/**
 * Creates a `EndTurn` object with the given arguments
 */
export const makeEndTurn = (value?: OmitPartial<EndTurn, '$kind' | 'id', 'diagnostics'>): EndTurn => ({
    $kind: BotElementKind.EndTurn,
    id: `endTurn_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Calls BotFrameworkAdapter.GetActivityMembers() and sets the result to a memory property
 */
export interface GetActivityMembers extends DialogAction
{
    readonly $kind: BotElementKind.GetActivityMembers;
    /**
     * Property path to put the value in
     */
    property?: PropertyPath;
    /**
     * The expression to get the value to put into property path
     */
    activityId?: StringExpression;
}

/**
 * Creates a `GetActivityMembers` object with the given arguments
 */
export const makeGetActivityMembers = (value?: OmitPartial<GetActivityMembers, '$kind' | 'id', 'diagnostics'>): GetActivityMembers => ({
    $kind: BotElementKind.GetActivityMembers,
    id: `getActivityMembers_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Calls BotFrameworkAdapter.GetConversationMembers () and sets the result to a memory property
 */
export interface GetConversationMembers extends DialogAction
{
    readonly $kind: BotElementKind.GetConversationMembers;
    /**
     * Property path to put the value in
     */
    property?: PropertyPath;
}

/**
 * Creates a `GetConversationMembers` object with the given arguments
 */
export const makeGetConversationMembers = (value?: OmitPartial<GetConversationMembers, '$kind' | 'id', 'diagnostics'>): GetConversationMembers => ({
    $kind: BotElementKind.GetConversationMembers,
    id: `getConversationMembers_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Goto an action by Id
 */
export interface GotoAction extends DialogAction
{
    readonly $kind: BotElementKind.GotoAction;
    /**
     * The action Id to goto
     */
    actionId: ActionId;
}

/**
 * Creates a `GotoAction` object with the given arguments
 */
export const makeGotoAction = (value: OmitPartial<GotoAction, '$kind' | 'id', 'diagnostics'>): GotoAction => ({
    $kind: BotElementKind.GotoAction,
    id: `gotoAction_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Action for performing an HttpRequest
 */
export interface HttpRequest extends DialogAction
{
    readonly $kind: BotElementKind.HttpRequest;
    /**
     * The HttpMethod to use
     */
    method?: EnumExpression<HttpMethod>;
    /**
     * The content type for the body of the http operation
     */
    contentType?: StringExpression;
    /**
     * The Url
     */
    url: StringExpression;
    /**
     * Headers
     */
    headers: Dictionary<StringExpression>;
    /**
     * Body payload
     */
    body?: ValueExpression;
    /**
     * The ResponseType
     */
    responseType?: EnumExpression<ResponseTypes>;
    /**
     * The property expression to store the HTTP response in
     */
    resultProperty?: PropertyPath;
}

/**
 * Creates a `HttpRequest` object with the given arguments
 */
export const makeHttpRequest = (value: OmitPartial<HttpRequest, '$kind' | 'id', 'headers' | 'diagnostics'>): HttpRequest => ({
    $kind: BotElementKind.HttpRequest,
    id: `httpRequest_${generateDesignerId()}`,
    headers: {},
    diagnostics: [],
    ...value
});


/**
 * Conditional branch
 */
export interface IfCondition extends DialogAction
{
    readonly $kind: BotElementKind.IfCondition;
    /**
     * The memory expression
     */
    condition: BoolExpression;
    /**
     * The actions to add to the plan when the rule constraints are met.
     */
    actions: DialogAction[];
    /**
     * The actions to add to the plan when the rule constraints are met.
     */
    elseActions: DialogAction[];
}

/**
 * Creates a `IfCondition` object with the given arguments
 */
export const makeIfCondition = (value: OmitPartial<IfCondition, '$kind' | 'id', 'actions' | 'elseActions' | 'diagnostics'>): IfCondition => ({
    $kind: BotElementKind.IfCondition,
    id: `ifCondition_${generateDesignerId()}`,
    actions: [],
    elseActions: [],
    diagnostics: [],
    ...value
});


/**
 * Conditional branching similar to an if / elseif / elseif / else chain
 */
export interface Condition extends DialogAction
{
    readonly $kind: BotElementKind.Condition;
    conditions: ConditionItem[];
    /**
     * The actions to add to the plan when the none of the Conditions constraints are met.
     */
    elseActions: DialogAction[];
}

/**
 * Creates a `Condition` object with the given arguments
 */
export const makeCondition = (value?: OmitPartial<Condition, '$kind' | 'id', 'conditions' | 'elseActions' | 'diagnostics'>): Condition => ({
    $kind: BotElementKind.Condition,
    id: `condition_${generateDesignerId()}`,
    conditions: [],
    elseActions: [],
    diagnostics: [],
    ...value
});


/**
 * Single conditional branch for an if or elseif
 */
export interface ConditionItem extends BotElement
{
    readonly $kind: BotElementKind.ConditionItem;
    /**
     * Unique identifier for a condition item.
     */
    id?: string;
    /**
     * The memory expression
     */
    condition: BoolExpression;
    /**
     * The actions to add to the plan when the rule constraints are met.
     */
    actions: DialogAction[];
}

/**
 * Creates a `ConditionItem` object with the given arguments
 */
export const makeConditionItem = (value: OmitPartial<ConditionItem, '$kind' | 'id', 'actions' | 'diagnostics'>): ConditionItem => ({
    $kind: BotElementKind.ConditionItem,
    id: `conditionItem_${generateDesignerId()}`,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * End the current conversation.
 */
export interface EndConversation extends DialogAction
{
    readonly $kind: BotElementKind.EndConversation;
}

/**
 * Creates a `EndConversation` object with the given arguments
 */
export const makeEndConversation = (value?: OmitPartial<EndConversation, '$kind' | 'id', 'diagnostics'>): EndConversation => ({
    $kind: BotElementKind.EndConversation,
    id: `endConversation_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Send a message back to the user
 */
export interface SendMessage extends DialogAction
{
    readonly $kind: BotElementKind.SendMessage;
    /**
     * Template for the message
     */
    message: MessageActivityTemplate;
}

/**
 * Creates a `SendMessage` object with the given arguments
 */
export const makeSendMessage = (value: OmitPartial<SendMessage, '$kind' | 'id', 'diagnostics'>): SendMessage => ({
    $kind: BotElementKind.SendMessage,
    id: `sendMessage_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Send an activity back to the user
 */
export interface SendActivity extends DialogAction
{
    readonly $kind: BotElementKind.SendActivity;
    /**
     * Template for the activity
     */
    activity: ActivityTemplateBase;
}

/**
 * Creates a `SendActivity` object with the given arguments
 */
export const makeSendActivity = (value: OmitPartial<SendActivity, '$kind' | 'id', 'diagnostics'>): SendActivity => ({
    $kind: BotElementKind.SendActivity,
    id: `sendActivity_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


export interface HandoffContext extends BotElement
{
}



export interface ExpressionHandoffContext extends HandoffContext
{
    readonly $kind: BotElementKind.ExpressionHandoffContext;
    /**
     * The context object to be included when sending the handoff activity
     */
    context?: ValueExpression;
}

/**
 * Creates a `ExpressionHandoffContext` object with the given arguments
 */
export const makeExpressionHandoffContext = (value?: OmitPartial<ExpressionHandoffContext, '$kind', 'diagnostics'>): ExpressionHandoffContext => ({
    $kind: BotElementKind.ExpressionHandoffContext,
    diagnostics: [],
    ...value
});


export interface AutomaticHandoffContext extends HandoffContext
{
    readonly $kind: BotElementKind.AutomaticHandoffContext;
    variables?: EnumExpression<HandoffVariablesList>;
}

/**
 * Creates a `AutomaticHandoffContext` object with the given arguments
 */
export const makeAutomaticHandoffContext = (value?: OmitPartial<AutomaticHandoffContext, '$kind', 'diagnostics'>): AutomaticHandoffContext => ({
    $kind: BotElementKind.AutomaticHandoffContext,
    diagnostics: [],
    ...value
});


/**
 * Send an handoff activity
 */
export interface SendHandoffActivity extends DialogAction
{
    readonly $kind: BotElementKind.SendHandoffActivity;
    /**
     * Template for the activity
     */
    messageToAgent?: ActivityTemplateBase;
    /**
     * The context object to be included when sending the handoff activity
     */
    handoffContext?: HandoffContext;
}

/**
 * Creates a `SendHandoffActivity` object with the given arguments
 */
export const makeSendHandoffActivity = (value?: OmitPartial<SendHandoffActivity, '$kind' | 'id', 'diagnostics'>): SendHandoffActivity => ({
    $kind: BotElementKind.SendHandoffActivity,
    id: `sendHandoffActivity_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Sets a property with the result of evaluating a value expression
 */
export interface SetProperties extends DialogAction
{
    readonly $kind: BotElementKind.SetProperties;
    /**
     * Additional property assignments
     */
    assignments: PropertyAssignment[];
}

/**
 * Creates a `SetProperties` object with the given arguments
 */
export const makeSetProperties = (value?: OmitPartial<SetProperties, '$kind' | 'id', 'assignments' | 'diagnostics'>): SetProperties => ({
    $kind: BotElementKind.SetProperties,
    id: `setProperties_${generateDesignerId()}`,
    assignments: [],
    diagnostics: [],
    ...value
});


/**
 * Sets a property with the result of evaluating a value expression
 */
export interface SetProperty extends DialogAction
{
    readonly $kind: BotElementKind.SetProperty;
    /**
     * Property path to put the value in
     */
    property: PropertyPath;
    /**
     * The expression to get the value to put into property path
     */
    value: ValueExpression;
}

/**
 * Creates a `SetProperty` object with the given arguments
 */
export const makeSetProperty = (value: OmitPartial<SetProperty, '$kind' | 'id', 'diagnostics'>): SetProperty => ({
    $kind: BotElementKind.SetProperty,
    id: `setProperty_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Send an activity back to the user
 */
export interface SignOutUser extends DialogAction
{
    readonly $kind: BotElementKind.SignOutUser;
}

/**
 * Creates a `SignOutUser` object with the given arguments
 */
export const makeSignOutUser = (value?: OmitPartial<SignOutUser, '$kind' | 'id', 'diagnostics'>): SignOutUser => ({
    $kind: BotElementKind.SignOutUser,
    id: `signOutUser_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Conditional branch with multiple cases
 */
export interface SwitchCondition extends DialogAction
{
    readonly $kind: BotElementKind.SwitchCondition;
    /**
     * Value expression against memory Example: "user.age"
     */
    condition: ValueExpression;
    /**
     * The actions to add to the plan when none of the Cases are met.
     */
    default: DialogAction[];
    /**
     * Cases
     */
    cases: Case[];
}

/**
 * Creates a `SwitchCondition` object with the given arguments
 */
export const makeSwitchCondition = (value: OmitPartial<SwitchCondition, '$kind' | 'id', 'default' | 'cases' | 'diagnostics'>): SwitchCondition => ({
    $kind: BotElementKind.SwitchCondition,
    id: `switchCondition_${generateDesignerId()}`,
    default: [],
    cases: [],
    diagnostics: [],
    ...value
});


/**
 * Track a custom event using IBotTelemetryClient
 */
export interface TelemetryTrackEventAction extends DialogAction
{
    readonly $kind: BotElementKind.TelemetryTrackEventAction;
    /**
     * A name to use for the event
     */
    eventName?: StringExpression;
    /**
     * The properties to attach to the tracked event
     */
    properties: Dictionary<StringExpression>;
}

/**
 * Creates a `TelemetryTrackEventAction` object with the given arguments
 */
export const makeTelemetryTrackEventAction = (value?: OmitPartial<TelemetryTrackEventAction, '$kind' | 'id', 'properties' | 'diagnostics'>): TelemetryTrackEventAction => ({
    $kind: BotElementKind.TelemetryTrackEventAction,
    id: `telemetryTrackEventAction_${generateDesignerId()}`,
    properties: {},
    diagnostics: [],
    ...value
});


/**
 * Send an Tace activity back to the transcript
 */
export interface TraceActivity extends DialogAction
{
    readonly $kind: BotElementKind.TraceActivity;
    /**
     * Name of the trace activity
     */
    name?: StringExpression;
    /**
     * Value type of the trace activity
     */
    valueType?: StringExpression;
    /**
     * Value expression to send as the value
     */
    value?: ValueExpression;
    /**
     * A label to use when describing a trace activity
     */
    label?: StringExpression;
}

/**
 * Creates a `TraceActivity` object with the given arguments
 */
export const makeTraceActivity = (value?: OmitPartial<TraceActivity, '$kind' | 'id', 'diagnostics'>): TraceActivity => ({
    $kind: BotElementKind.TraceActivity,
    id: `traceActivity_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Update an activity with replacement
 */
export interface UpdateActivity extends DialogAction
{
    readonly $kind: BotElementKind.UpdateActivity;
    /**
     * Template for the activity
     */
    activity?: ActivityTemplateBase;
    /**
     * The expression which resolves to the activityId to update
     */
    activityId?: StringExpression;
}

/**
 * Creates a `UpdateActivity` object with the given arguments
 */
export const makeUpdateActivity = (value?: OmitPartial<UpdateActivity, '$kind' | 'id', 'diagnostics'>): UpdateActivity => ({
    $kind: BotElementKind.UpdateActivity,
    id: `updateActivity_${generateDesignerId()}`,
    diagnostics: [],
    ...value
});


/**
 * Container for the list of actions that are out of normal execution flow. It's still possible that question initializer references an action here and the action can be executed. Bot publish should give validation errors if the bot has at least one disconnected node container.
 */
export interface DisconnectedNodeContainer extends ActionScopeBase
{
    readonly $kind: BotElementKind.DisconnectedNodeContainer;
}

/**
 * Creates a `DisconnectedNodeContainer` object with the given arguments
 */
export const makeDisconnectedNodeContainer = (value?: OmitPartial<DisconnectedNodeContainer, '$kind' | 'id', 'actions' | 'diagnostics'>): DisconnectedNodeContainer => ({
    $kind: BotElementKind.DisconnectedNodeContainer,
    id: `disconnectedNodeContainer_${generateDesignerId()}`,
    actions: [],
    diagnostics: [],
    ...value
});


/**
 * Contains options used to control how choices are recognized in a users utterance
 */
export interface FindChoicesOptions
{
    /**
     * A value indicating whether only some of the tokens in a value need to exist to be considered. a match. The default value is "false". This is optional
     */
    allowPartialMatches?: boolean;
    /**
     * The locale/culture code of the utterance. The default is `en-US`. This is optional
     */
    locale?: string;
    /**
     * The maximum tokens allowed between two matched tokens in the utterance. So with. a max distance of 2 the value "second last" would match the utterance "second from the last". but it wouldn't match "Wait a second. That's not the last one is it?". The default value is "2"
     */
    maxTokenDistance?: number | null;
    /**
     * A value indicating whether the choices value will NOT be search over. The default is <c>false</c>. This is optional
     */
    noValue?: boolean;
    /**
     * A value indicating whether the title of the choices action will NOT be searched over. The default is <c>false</c>. This is optional
     */
    noAction?: boolean;
    /**
     * A value indicating whether the recognizer should check for Numbers using the NumberRecognizer's. NumberModel
     */
    recognizeNumbers?: boolean;
    /**
     * A value indicating whether the recognizer should check for Ordinal Numbers using the NumberRecognizer's. OrdinalModel
     */
    recognizeOrdinals?: boolean;
}



export interface Choice
{
    /**
     * The value to return when selected
     */
    value?: string;
    /**
     * The action to use when rendering the choice as a suggested action or hero card. This is optional
     */
    action?: CardActionDefinition;
    /**
     * The list of synonyms to recognize in addition to the value. This is optional
     */
    synonyms: string[];
}



export interface ChoiceFactoryOptions
{
    /**
     * The character used to separate individual choices when there are more than 2 choices. The default value is `", "`. This is optional
     */
    inlineSeparator?: string;
    /**
     * The separator inserted between the choices when their are only 2 choices. The default. value is `" or "`. This is optional
     */
    inlineOr?: string;
    /**
     * The separator inserted between the last 2 choices when their are more than 2 choices. The default value is `", or "`. This is optional
     */
    inlineOrMore?: string;
    /**
     * A value indicating whether an inline and list style choices will be prefixed with the index of the. choice as in "1. choice". If <see langword="false" />, the list style will use a bulleted list instead.The default value is <see langword="true" />
     */
    includeNumbers?: boolean | null;
}



export interface CardActionDefinition extends BotElement
{
    readonly $kind: BotElementKind.CardActionDefinition;
    /**
     * Text description which appears on the button
     */
    title?: string;
    /**
     * The type of action implemented by this button. Possible values include: 'openUrl', 'imBack', 'postBack','playAudio', 'playVideo', 'showImage', 'downloadFile', 'signin', 'call', 'messageBack'
     */
    type?: ActionType;
    /**
     * Supplementary parameter for action. Content of this property depends on the the selected Type.
     */
    value?: DataValue;
    /**
     * Text for this action
     */
    text?: string;
    /**
     * Text to display in the chat feed if the button is clicked
     */
    displayText?: string;
    /**
     * Image URL which will appear on the button, next to text label
     */
    image?: string;
    /**
     * Alternate text to be used for the Image property
     */
    imageAltText?: string;
    /**
     * Channel-specific data associated with this action
     */
    channelData?: DataValue;
}

/**
 * Creates a `CardActionDefinition` object with the given arguments
 */
export const makeCardActionDefinition = (value?: OmitPartial<CardActionDefinition, '$kind', 'diagnostics'>): CardActionDefinition => ({
    $kind: BotElementKind.CardActionDefinition,
    diagnostics: [],
    ...value
});


export interface PropertyAssignment extends BotElement
{
    readonly $kind: BotElementKind.PropertyAssignment;
    /**
     * The property path
     */
    property: PropertyPath;
    /**
     * The value to set
     */
    value: ValueExpression;
}

/**
 * Creates a `PropertyAssignment` object with the given arguments
 */
export const makePropertyAssignment = (value: OmitPartial<PropertyAssignment, '$kind', 'diagnostics'>): PropertyAssignment => ({
    $kind: BotElementKind.PropertyAssignment,
    diagnostics: [],
    ...value
});


/**
 * Binds value expressions to the action inputs
 */
export interface ActionInputBinding extends BotElement
{
    readonly $kind: BotElementKind.ActionInputBinding;
    /**
     * Key maps to the property in the action's input
     */
    binding: Dictionary<ValueExpression>;
}

/**
 * Creates a `ActionInputBinding` object with the given arguments
 */
export const makeActionInputBinding = (value?: OmitPartial<ActionInputBinding, '$kind', 'binding' | 'diagnostics'>): ActionInputBinding => ({
    $kind: BotElementKind.ActionInputBinding,
    binding: {},
    diagnostics: [],
    ...value
});


/**
 * Binds action outputs to the properties
 */
export interface ActionOutputBinding extends BotElement
{
    readonly $kind: BotElementKind.ActionOutputBinding;
    /**
     * Key maps to the property in the action's output. Value maps to the variable that should store the property.
     */
    binding: Dictionary<PropertyPath>;
}

/**
 * Creates a `ActionOutputBinding` object with the given arguments
 */
export const makeActionOutputBinding = (value?: OmitPartial<ActionOutputBinding, '$kind', 'binding' | 'diagnostics'>): ActionOutputBinding => ({
    $kind: BotElementKind.ActionOutputBinding,
    binding: {},
    diagnostics: [],
    ...value
});


export interface BotConfiguration
{
    categories: Category[];
    channels: ChannelDefinition[];
    settings: Dictionary<DataValue>;
    /**
     * This dictionary will be the source of voice settings with Language (to support multi-lang) as the key and voiceSetting as the value.
     */
    voiceSettings: Dictionary<VoiceSetting>;
}



export interface Category
{
    id?: string;
    displayName?: string;
}



/**
 * This is used to store the current voice font details for the bot. This object is not of the type enum as there are more than 300 supported voice types in GA and the list is not constant. To avoid manual updation of the enum, the field is made a string.
 */
export interface VoiceSetting
{
    /**
     * Voice Short Name eg: 'en-US-JennyNeural', this name is used to display the selected voice font to the client and also to fetch the audio voice stream from the cognitive services
     */
    voiceFont?: string;
    /**
     * This is used to describe the style in which the selected voice font speaks during a conversation. THe object is not of the type enum as the list is not standard across all the fonts.
     */
    voiceStyle?: string;
}



export interface ChannelDefinition
{
    id?: string;
    channelId?: ChannelId;
    channelSpecifier?: string;
    displayName?: string;
}



export interface TeamsApplicationDetails
{
    version?: string;
    botChannelRegistrationAppId?: string;
    colorIcon?: string;
    outlineIcon?: string;
    accentColor?: string;
    shortDescription?: string;
    longDescription?: string;
    developerName?: string;
    websiteLink?: string;
    termsLink?: string;
    privacyLink?: string;
    microsoftPartnerNetworkId?: string;
    isPowerPlatformStoreDiscoverable?: string;
    singleSignOnAadApplicationClientId?: string;
    singleSignOnResourceLink?: string;
    auditInfo?: AuditInfo;
}



/**
 * Object describing the details on the latest async operations
 */
export interface BotSynchronizationDetails
{
    lastFinishedPublishOperation?: PublishResultDetails;
}



export interface PublishResultDetails
{
    userId?: Guid;
    operationStart?: DateTime;
    operationEnd?: DateTime;
    status?: PublishResult;
    /**
     * List of warnings and errors associated with the operation
     */
    diagnosticDetails: DiagnosticResult[];
}



export interface DiagnosticResult
{
    readonly $kind: DiagnosticResultKind;
    /**
     * The underlying diagnostics
     */
    diagnosticList: BotElementDiagnostic[];
    /**
     * The component attached to the diagnostic
     */
    componentId: BotComponentId;
}



export interface ComponentDiagnosticResult extends DiagnosticResult
{
    readonly $kind: DiagnosticResultKind.ComponentDiagnosticResult;
}

/**
 * Creates a `ComponentDiagnosticResult` object with the given arguments
 */
export const makeComponentDiagnosticResult = (value: OmitPartial<ComponentDiagnosticResult, '$kind', 'diagnosticList'>): ComponentDiagnosticResult => ({
    $kind: DiagnosticResultKind.ComponentDiagnosticResult,
    diagnosticList: [],
    ...value
});


export interface ActionReferenceDiagnosticResult extends DiagnosticResult
{
    readonly $kind: DiagnosticResultKind.ActionReferenceDiagnosticResult;
    /**
     * Reference to a particular action
     */
    reference?: ActionReference;
}

/**
 * Creates a `ActionReferenceDiagnosticResult` object with the given arguments
 */
export const makeActionReferenceDiagnosticResult = (value: OmitPartial<ActionReferenceDiagnosticResult, '$kind', 'diagnosticList'>): ActionReferenceDiagnosticResult => ({
    $kind: DiagnosticResultKind.ActionReferenceDiagnosticResult,
    diagnosticList: [],
    ...value
});


export interface ContentShareContext extends BotElement
{
    readonly $kind: BotElementKind.ContentShareContext;
    reusePolicy?: BotComponentReusePolicy;
    iconUri?: string;
    helpUri?: string;
    accentColor?: string;
}

/**
 * Creates a `ContentShareContext` object with the given arguments
 */
export const makeContentShareContext = (value?: OmitPartial<ContentShareContext, '$kind', 'diagnostics'>): ContentShareContext => ({
    $kind: BotElementKind.ContentShareContext,
    diagnostics: [],
    ...value
});


export interface ManagedProperties extends BotElement
{
    readonly $kind: BotElementKind.ManagedProperties;
    isManaged?: boolean;
    isCustomizable?: boolean;
    solutionId?: string;
}

/**
 * Creates a `ManagedProperties` object with the given arguments
 */
export const makeManagedProperties = (value?: OmitPartial<ManagedProperties, '$kind', 'diagnostics'>): ManagedProperties => ({
    $kind: BotElementKind.ManagedProperties,
    diagnostics: [],
    ...value
});


export interface AuditInfo
{
    createdTimeUtc?: DateTime;
    modifiedTimeUtc?: DateTime;
    /**
     * Azure AD Object ID that created this item.
     */
    createdBy?: Guid;
    /**
     * Azure AD Object ID that last modified this item.
     */
    modifiedBy?: Guid;
}



export interface LanguageUnderstandingElement extends BotElement
{
}



/**
 * Pointer to either a prebuilt entity or a user-defined custom entity.
 */
export interface EntityReference extends LanguageUnderstandingElement
{
}



export interface EmbeddedEntity extends EntityReference
{
    readonly $kind: BotElementKind.EmbeddedEntity;
    /**
     * The actual embedded entity
     */
    definition: Entity;
    displayName?: string;
}

/**
 * Creates a `EmbeddedEntity` object with the given arguments
 */
export const makeEmbeddedEntity = (value: OmitPartial<EmbeddedEntity, '$kind', 'diagnostics'>): EmbeddedEntity => ({
    $kind: BotElementKind.EmbeddedEntity,
    diagnostics: [],
    ...value
});


export interface PrebuiltEntityReference extends EntityReference
{
    readonly $kind: BotElementKind.PrebuiltEntityReference;
    type: PrebuiltEntityName;
}

/**
 * Creates a `PrebuiltEntityReference` object with the given arguments
 */
export const makePrebuiltEntityReference = (value: OmitPartial<PrebuiltEntityReference, '$kind', 'diagnostics'>): PrebuiltEntityReference => ({
    $kind: BotElementKind.PrebuiltEntityReference,
    diagnostics: [],
    ...value
});


export interface RegexEntityReference extends EntityReference
{
    readonly $kind: BotElementKind.RegexEntityReference;
    entityId: CustomEntitySchemaName;
}

/**
 * Creates a `RegexEntityReference` object with the given arguments
 */
export const makeRegexEntityReference = (value: OmitPartial<RegexEntityReference, '$kind', 'diagnostics'>): RegexEntityReference => ({
    $kind: BotElementKind.RegexEntityReference,
    diagnostics: [],
    ...value
});


export interface ClosedListEntityReference extends EntityReference
{
    readonly $kind: BotElementKind.ClosedListEntityReference;
    entityId: CustomEntitySchemaName;
    /**
     * Selected items to be shown to the user.
     */
    selectedItems: ClosedListItemId[];
}

/**
 * Creates a `ClosedListEntityReference` object with the given arguments
 */
export const makeClosedListEntityReference = (value: OmitPartial<ClosedListEntityReference, '$kind', 'selectedItems' | 'diagnostics'>): ClosedListEntityReference => ({
    $kind: BotElementKind.ClosedListEntityReference,
    selectedItems: [],
    diagnostics: [],
    ...value
});


export interface Entity extends LanguageUnderstandingElement
{
}



export interface RegexEntity extends Entity
{
    readonly $kind: BotElementKind.RegexEntity;
    pattern?: string;
}

/**
 * Creates a `RegexEntity` object with the given arguments
 */
export const makeRegexEntity = (value?: OmitPartial<RegexEntity, '$kind', 'diagnostics'>): RegexEntity => ({
    $kind: BotElementKind.RegexEntity,
    diagnostics: [],
    ...value
});


export interface ClosedListEntity extends Entity
{
    readonly $kind: BotElementKind.ClosedListEntity;
    smartMatchingEnabled?: boolean | null;
    items: ClosedListItem[];
}

/**
 * Creates a `ClosedListEntity` object with the given arguments
 */
export const makeClosedListEntity = (value?: OmitPartial<ClosedListEntity, '$kind', 'items' | 'diagnostics'>): ClosedListEntity => ({
    $kind: BotElementKind.ClosedListEntity,
    items: [],
    diagnostics: [],
    ...value
});


/**
 * Formerly known as NamedEntity.
 */
export interface ClosedListItem extends LanguageUnderstandingElement
{
    readonly $kind: BotElementKind.ClosedListItem;
    /**
     * Unique identifier for this element in the closed list. Should be the same across languages.
     */
    id: ClosedListItemId;
    /**
     * Visible display name for this item. Used to populate multiple choice options.
     */
    displayName: string;
    synonyms: string[];
}

/**
 * Creates a `ClosedListItem` object with the given arguments
 */
export const makeClosedListItem = (value: OmitPartial<ClosedListItem, '$kind', 'synonyms' | 'diagnostics'>): ClosedListItem => ({
    $kind: BotElementKind.ClosedListItem,
    synonyms: [],
    diagnostics: [],
    ...value
});


export interface LanguageGenerationElement extends BotElement
{
}



export interface TemplateSegment extends LanguageGenerationElement
{
}



export interface TextSegment extends TemplateSegment
{
    readonly $kind: BotElementKind.TextSegment;
    value?: string;
}

/**
 * Creates a `TextSegment` object with the given arguments
 */
export const makeTextSegment = (value?: OmitPartial<TextSegment, '$kind', 'diagnostics'>): TextSegment => ({
    $kind: BotElementKind.TextSegment,
    diagnostics: [],
    ...value
});


export interface ExpressionSegment extends TemplateSegment
{
    readonly $kind: BotElementKind.ExpressionSegment;
    expression?: ValueExpression;
}

/**
 * Creates a `ExpressionSegment` object with the given arguments
 */
export const makeExpressionSegment = (value?: OmitPartial<ExpressionSegment, '$kind', 'diagnostics'>): ExpressionSegment => ({
    $kind: BotElementKind.ExpressionSegment,
    diagnostics: [],
    ...value
});


export interface TemplateLine extends LanguageGenerationElement
{
    readonly $kind: BotElementKind.TemplateLine;
    segments: TemplateSegment[];
}

/**
 * Creates a `TemplateLine` object with the given arguments
 */
export const makeTemplateLine = (value?: OmitPartial<TemplateLine, '$kind', 'segments' | 'diagnostics'>): TemplateLine => ({
    $kind: BotElementKind.TemplateLine,
    segments: [],
    diagnostics: [],
    ...value
});


/**
 * Represents a reference/pointer to a language generation template.
 */
export interface TemplateReference extends LanguageGenerationElement
{
    readonly $kind: BotElementKind.TemplateReference;
    templateId?: string;
    arguments: ValueExpression[];
    /**
     * Original string, handling error cases and literal templates.
     */
    originalString?: string;
}

/**
 * Creates a `TemplateReference` object with the given arguments
 */
export const makeTemplateReference = (value?: OmitPartial<TemplateReference, '$kind', 'arguments' | 'diagnostics'>): TemplateReference => ({
    $kind: BotElementKind.TemplateReference,
    arguments: [],
    diagnostics: [],
    ...value
});


export interface LanguageGenerationTemplate extends LanguageGenerationElement
{
    readonly $kind: BotElementKind.LanguageGenerationTemplate;
    /**
     * Unique name for this template
     */
    templateId?: string;
    /**
     * List of parameter names.
     */
    parameters: string[];
    /**
     * Content of the template
     */
    body?: TemplateBody;
}

/**
 * Creates a `LanguageGenerationTemplate` object with the given arguments
 */
export const makeLanguageGenerationTemplate = (value?: OmitPartial<LanguageGenerationTemplate, '$kind', 'parameters' | 'diagnostics'>): LanguageGenerationTemplate => ({
    $kind: BotElementKind.LanguageGenerationTemplate,
    parameters: [],
    diagnostics: [],
    ...value
});


export interface TemplateBody extends LanguageGenerationElement
{
}



export interface NormalTemplateBody extends TemplateBody
{
    readonly $kind: BotElementKind.NormalTemplateBody;
    entries: TemplateLine[];
}

/**
 * Creates a `NormalTemplateBody` object with the given arguments
 */
export const makeNormalTemplateBody = (value?: OmitPartial<NormalTemplateBody, '$kind', 'entries' | 'diagnostics'>): NormalTemplateBody => ({
    $kind: BotElementKind.NormalTemplateBody,
    entries: [],
    diagnostics: [],
    ...value
});


export interface TemplateSwitchCase extends LanguageGenerationElement
{
    readonly $kind: BotElementKind.TemplateSwitchCase;
    expression?: ValueExpression;
    body?: NormalTemplateBody;
}

/**
 * Creates a `TemplateSwitchCase` object with the given arguments
 */
export const makeTemplateSwitchCase = (value?: OmitPartial<TemplateSwitchCase, '$kind', 'diagnostics'>): TemplateSwitchCase => ({
    $kind: BotElementKind.TemplateSwitchCase,
    diagnostics: [],
    ...value
});


export interface TemplateIfCondition extends LanguageGenerationElement
{
    readonly $kind: BotElementKind.TemplateIfCondition;
    expression?: BoolExpression;
    body?: NormalTemplateBody;
}

/**
 * Creates a `TemplateIfCondition` object with the given arguments
 */
export const makeTemplateIfCondition = (value?: OmitPartial<TemplateIfCondition, '$kind', 'diagnostics'>): TemplateIfCondition => ({
    $kind: BotElementKind.TemplateIfCondition,
    diagnostics: [],
    ...value
});


export interface IfElseTemplateBody extends TemplateBody
{
    readonly $kind: BotElementKind.IfElseTemplateBody;
    conditions: TemplateIfCondition[];
    else?: NormalTemplateBody;
}

/**
 * Creates a `IfElseTemplateBody` object with the given arguments
 */
export const makeIfElseTemplateBody = (value?: OmitPartial<IfElseTemplateBody, '$kind', 'conditions' | 'diagnostics'>): IfElseTemplateBody => ({
    $kind: BotElementKind.IfElseTemplateBody,
    conditions: [],
    diagnostics: [],
    ...value
});


export interface SwitchTemplateBody extends TemplateBody
{
    readonly $kind: BotElementKind.SwitchTemplateBody;
    switchExpression?: ValueExpression;
    cases: TemplateSwitchCase[];
    default?: NormalTemplateBody;
}

/**
 * Creates a `SwitchTemplateBody` object with the given arguments
 */
export const makeSwitchTemplateBody = (value?: OmitPartial<SwitchTemplateBody, '$kind', 'cases' | 'diagnostics'>): SwitchTemplateBody => ({
    $kind: BotElementKind.SwitchTemplateBody,
    cases: [],
    diagnostics: [],
    ...value
});


export interface PropertyEntry extends LanguageGenerationElement
{
}



export interface StructuredTemplateInvocation extends PropertyEntry
{
    readonly $kind: BotElementKind.StructuredTemplateInvocation;
    templateInvocationExpression?: TemplateReference;
}

/**
 * Creates a `StructuredTemplateInvocation` object with the given arguments
 */
export const makeStructuredTemplateInvocation = (value?: OmitPartial<StructuredTemplateInvocation, '$kind', 'diagnostics'>): StructuredTemplateInvocation => ({
    $kind: BotElementKind.StructuredTemplateInvocation,
    diagnostics: [],
    ...value
});


export interface StructuredProperty extends PropertyEntry
{
    propertyName?: string;
}



export interface StructuredPropertyWithLine extends StructuredProperty
{
    readonly $kind: BotElementKind.StructuredPropertyWithLine;
    propertyBody?: TemplateLine;
}

/**
 * Creates a `StructuredPropertyWithLine` object with the given arguments
 */
export const makeStructuredPropertyWithLine = (value?: OmitPartial<StructuredPropertyWithLine, '$kind', 'diagnostics'>): StructuredPropertyWithLine => ({
    $kind: BotElementKind.StructuredPropertyWithLine,
    diagnostics: [],
    ...value
});


export interface StructuredPropertyWithList extends StructuredProperty
{
    readonly $kind: BotElementKind.StructuredPropertyWithList;
    optionList: TemplateLine[];
}

/**
 * Creates a `StructuredPropertyWithList` object with the given arguments
 */
export const makeStructuredPropertyWithList = (value?: OmitPartial<StructuredPropertyWithList, '$kind', 'optionList' | 'diagnostics'>): StructuredPropertyWithList => ({
    $kind: BotElementKind.StructuredPropertyWithList,
    optionList: [],
    diagnostics: [],
    ...value
});


export interface StructuredTemplateBody extends TemplateBody
{
    readonly $kind: BotElementKind.StructuredTemplateBody;
    structuredTemplateName?: string;
    propertyList: PropertyEntry[];
}

/**
 * Creates a `StructuredTemplateBody` object with the given arguments
 */
export const makeStructuredTemplateBody = (value?: OmitPartial<StructuredTemplateBody, '$kind', 'propertyList' | 'diagnostics'>): StructuredTemplateBody => ({
    $kind: BotElementKind.StructuredTemplateBody,
    propertyList: [],
    diagnostics: [],
    ...value
});


export interface ActivityTemplateBase extends LanguageGenerationElement
{
    channelData?: RecordDataValue;
    /**
     * A value that is associated with the activity.
     */
    value?: RecordDataValue;
}



export interface ActivityTemplate extends ActivityTemplateBase
{
    readonly $kind: BotElementKind.ActivityTemplate;
    type?: StringExpression;
}

/**
 * Creates a `ActivityTemplate` object with the given arguments
 */
export const makeActivityTemplate = (value?: OmitPartial<ActivityTemplate, '$kind', 'diagnostics'>): ActivityTemplate => ({
    $kind: BotElementKind.ActivityTemplate,
    diagnostics: [],
    ...value
});


export interface MessageActivityTemplate extends ActivityTemplateBase
{
    readonly $kind: BotElementKind.MessageActivityTemplate;
    /**
     * Message variations to be displayed as text content on the channel. Supports markdown format.
     */
    text: TemplateLine[];
    /**
     * Speech variations. Supports SSML markup.
     */
    speak: TemplateLine[];
    /**
     * Input hint to indicate whether the channel should be accepting, ignoring or expecting input.
     */
    inputHint?: InputHint;
    /**
     * List of Attachments.
     */
    attachments: ActivityAttachment[];
    /**
     * The layout hint for multiple attachments. Default: list. Possible values include: 'list','carousel'
     */
    attachmentLayout?: AttachmentLayout;
    /**
     * The text to display if the channel cannot render cards.
     */
    summary?: string;
    /**
     * The Quick Replies to be sent as part of the message.
     */
    suggestedActions: CardActionDefinition[];
    /**
     * The time at which the activity should be considered to be "expired" and should not be\npresented to the recipient.
     */
    expiration?: string;
    /**
     * The importance of the activity. Possible values include: 'low', 'normal', 'high'
     */
    importance?: ActivityImportance;
}

/**
 * Creates a `MessageActivityTemplate` object with the given arguments
 */
export const makeMessageActivityTemplate = (value?: OmitPartial<MessageActivityTemplate, '$kind', 'text' | 'speak' | 'attachments' | 'suggestedActions' | 'diagnostics'>): MessageActivityTemplate => ({
    $kind: BotElementKind.MessageActivityTemplate,
    text: [],
    speak: [],
    attachments: [],
    suggestedActions: [],
    diagnostics: [],
    ...value
});


export interface ActivityAttachment extends LanguageGenerationElement
{
}



export interface VideoCardTemplate extends ActivityAttachment
{
    readonly $kind: BotElementKind.VideoCardTemplate;
    /**
     * Title for the card
     */
    title?: StringExpression;
    /**
     * Subtitle for the card
     */
    subtitle?: StringExpression;
    /**
     * Image URL
     */
    image?: StringExpression;
    /**
     * Video URL
     */
    media?: StringExpression;
    /**
     * Text for the card
     */
    text?: StringExpression;
    /**
     * One or more buttons to be added to the video card.
     */
    buttons: CardActionDefinition[];
}

/**
 * Creates a `VideoCardTemplate` object with the given arguments
 */
export const makeVideoCardTemplate = (value?: OmitPartial<VideoCardTemplate, '$kind', 'buttons' | 'diagnostics'>): VideoCardTemplate => ({
    $kind: BotElementKind.VideoCardTemplate,
    buttons: [],
    diagnostics: [],
    ...value
});


export interface ImageCardTemplate extends ActivityAttachment
{
    readonly $kind: BotElementKind.ImageCardTemplate;
    /**
     * Title for the image
     */
    title?: StringExpression;
    /**
     * Image URL
     */
    image?: StringExpression;
}

/**
 * Creates a `ImageCardTemplate` object with the given arguments
 */
export const makeImageCardTemplate = (value?: OmitPartial<ImageCardTemplate, '$kind', 'diagnostics'>): ImageCardTemplate => ({
    $kind: BotElementKind.ImageCardTemplate,
    diagnostics: [],
    ...value
});


export interface AdaptiveCardTemplate extends ActivityAttachment
{
    readonly $kind: BotElementKind.AdaptiveCardTemplate;
    /**
     * Content for the card
     */
    cardContent: StringExpression;
}

/**
 * Creates a `AdaptiveCardTemplate` object with the given arguments
 */
export const makeAdaptiveCardTemplate = (value: OmitPartial<AdaptiveCardTemplate, '$kind', 'diagnostics'>): AdaptiveCardTemplate => ({
    $kind: BotElementKind.AdaptiveCardTemplate,
    diagnostics: [],
    ...value
});


export interface HeroCardTemplate extends ActivityAttachment
{
    readonly $kind: BotElementKind.HeroCardTemplate;
    /**
     * Title for the card
     */
    title?: StringExpression;
    /**
     * Subtitle for the card
     */
    subtitle?: StringExpression;
    /**
     * Image URL
     */
    image?: StringExpression;
    /**
     * Text for the card
     */
    text?: StringExpression;
    /**
     * Set of actions applicable to the current card
     */
    buttons: CardActionDefinition[];
}

/**
 * Creates a `HeroCardTemplate` object with the given arguments
 */
export const makeHeroCardTemplate = (value?: OmitPartial<HeroCardTemplate, '$kind', 'buttons' | 'diagnostics'>): HeroCardTemplate => ({
    $kind: BotElementKind.HeroCardTemplate,
    buttons: [],
    diagnostics: [],
    ...value
});


export interface DataType
{
    readonly $kind: DataTypeKind;
}



/**
 * Unspecified is an authoring-time type. It is a subtype of all other types. It represents a type that is not yet known, and it is used primarily for analysis purposes.
 */
export interface UnspecifiedDataType extends DataType
{
    readonly $kind: DataTypeKind.UnspecifiedDataType;
}

/**
 * Creates a `UnspecifiedDataType` object with the given arguments
 */
export const makeUnspecifiedDataType = (value?: Omit<UnspecifiedDataType, '$kind'>): UnspecifiedDataType => ({
    $kind: DataTypeKind.UnspecifiedDataType,
    ...value
});


export interface BlankType extends DataType
{
    readonly $kind: DataTypeKind.BlankType;
}

/**
 * Creates a `BlankType` object with the given arguments
 */
export const makeBlankType = (value?: Omit<BlankType, '$kind'>): BlankType => ({
    $kind: DataTypeKind.BlankType,
    ...value
});


export interface BooleanDataType extends DataType
{
    readonly $kind: DataTypeKind.BooleanDataType;
}

/**
 * Creates a `BooleanDataType` object with the given arguments
 */
export const makeBooleanDataType = (value?: Omit<BooleanDataType, '$kind'>): BooleanDataType => ({
    $kind: DataTypeKind.BooleanDataType,
    ...value
});


export interface NumberDataType extends DataType
{
    readonly $kind: DataTypeKind.NumberDataType;
}

/**
 * Creates a `NumberDataType` object with the given arguments
 */
export const makeNumberDataType = (value?: Omit<NumberDataType, '$kind'>): NumberDataType => ({
    $kind: DataTypeKind.NumberDataType,
    ...value
});


export interface StringDataType extends DataType
{
    readonly $kind: DataTypeKind.StringDataType;
}

/**
 * Creates a `StringDataType` object with the given arguments
 */
export const makeStringDataType = (value?: Omit<StringDataType, '$kind'>): StringDataType => ({
    $kind: DataTypeKind.StringDataType,
    ...value
});


export interface TimeSpanDataType extends DataType
{
    readonly $kind: DataTypeKind.TimeSpanDataType;
}

/**
 * Creates a `TimeSpanDataType` object with the given arguments
 */
export const makeTimeSpanDataType = (value?: Omit<TimeSpanDataType, '$kind'>): TimeSpanDataType => ({
    $kind: DataTypeKind.TimeSpanDataType,
    ...value
});


export interface DateTimeDataType extends DataType
{
    readonly $kind: DataTypeKind.DateTimeDataType;
}

/**
 * Creates a `DateTimeDataType` object with the given arguments
 */
export const makeDateTimeDataType = (value?: Omit<DateTimeDataType, '$kind'>): DateTimeDataType => ({
    $kind: DataTypeKind.DateTimeDataType,
    ...value
});


/**
 * Represent an untyped value. The type is determined at runtime. Variables cannot be assigned this type.
 */
export interface AnyType extends DataType
{
    readonly $kind: DataTypeKind.AnyType;
}

/**
 * Creates a `AnyType` object with the given arguments
 */
export const makeAnyType = (value?: Omit<AnyType, '$kind'>): AnyType => ({
    $kind: DataTypeKind.AnyType,
    ...value
});


export interface PropertyInfo
{
    displayName?: string;
    description?: string;
    isRequired?: boolean;
    type?: DataType;
}



export interface AggregateDataType extends DataType
{
    properties: Dictionary<PropertyInfo>;
}



export interface TableDataType extends AggregateDataType
{
    readonly $kind: DataTypeKind.TableDataType;
}

/**
 * Creates a `TableDataType` object with the given arguments
 */
export const makeTableDataType = (value?: OmitPartial<TableDataType, '$kind', 'properties'>): TableDataType => ({
    $kind: DataTypeKind.TableDataType,
    properties: {},
    ...value
});


export interface RecordDataType extends AggregateDataType
{
    readonly $kind: DataTypeKind.RecordDataType;
}

/**
 * Creates a `RecordDataType` object with the given arguments
 */
export const makeRecordDataType = (value?: OmitPartial<RecordDataType, '$kind', 'properties'>): RecordDataType => ({
    $kind: DataTypeKind.RecordDataType,
    properties: {},
    ...value
});


/**
 * Base type for option sets, implemented by referencing an existing asset in the object model. 
 */
export interface OptionSetDataType extends DataType
{
}



/**
 * Option set type referencing a shared closed list entity.
 */
export interface ClosedListOptionSetDataType extends OptionSetDataType
{
    readonly $kind: DataTypeKind.ClosedListOptionSetDataType;
    schemaName: CustomEntitySchemaName;
}

/**
 * Creates a `ClosedListOptionSetDataType` object with the given arguments
 */
export const makeClosedListOptionSetDataType = (value: Omit<ClosedListOptionSetDataType, '$kind'>): ClosedListOptionSetDataType => ({
    $kind: DataTypeKind.ClosedListOptionSetDataType,
    ...value
});


/**
 * Option set type referencing a closed list embedded within a question node.
 */
export interface EmbeddedOptionSetDataType extends OptionSetDataType
{
    readonly $kind: DataTypeKind.EmbeddedOptionSetDataType;
    /**
     * The dialog in which the trigger is defined
     */
    dialogSchemaName: DialogSchemaName;
    /**
     * The trigger in which the question node is defined.
     */
    triggerId: TriggerId;
    /**
     * The id of the question node defining the option set.
     */
    actionId: ActionId;
}

/**
 * Creates a `EmbeddedOptionSetDataType` object with the given arguments
 */
export const makeEmbeddedOptionSetDataType = (value: Omit<EmbeddedOptionSetDataType, '$kind'>): EmbeddedOptionSetDataType => ({
    $kind: DataTypeKind.EmbeddedOptionSetDataType,
    ...value
});


/**
 * Option set type referencing a system option set.
 */
export interface SystemOptionSetDataType extends OptionSetDataType
{
    readonly $kind: DataTypeKind.SystemOptionSetDataType;
    /**
     * The name of the option set type.
     */
    name: SystemOptionSetName;
}

/**
 * Creates a `SystemOptionSetDataType` object with the given arguments
 */
export const makeSystemOptionSetDataType = (value: Omit<SystemOptionSetDataType, '$kind'>): SystemOptionSetDataType => ({
    $kind: DataTypeKind.SystemOptionSetDataType,
    ...value
});


export interface OptionDataValue
{
    readonly $kind: DataValueKind.OptionDataValue;
    type: OptionSetDataType;
    value: OptionName;
}

/**
 * Creates a `OptionDataValue` object with the given arguments
 */
export const makeOptionDataValue = (value: Omit<OptionDataValue, '$kind'>): OptionDataValue => ({
    $kind: DataValueKind.OptionDataValue,
    ...value
});


/**
 * Represents a single diagnostic. Diagnostics can be attached to the bot elements.
 */
export interface BotElementDiagnostic
{
    readonly $kind: BotElementDiagnosticKind;
}



export interface BotElementIssue extends BotElementDiagnostic
{
    /**
     * List of suggestions that can solve this issue
     */
    suggestions: BotElementSuggestion[];
}



export interface BotElementError extends BotElementIssue
{
}



export interface BotElementWarning extends BotElementIssue
{
}



export interface PropertyErrorBase extends BotElementError
{
    /**
     * The schema name of the property
     */
    propertyName?: string;
}



/**
 * Occurs when an expression does not return its assigned type.
 */
export interface IncorrectTypeError extends BotElementError
{
    readonly $kind: BotElementDiagnosticKind.IncorrectTypeError;
    /**
     * The determined type of the variable or property.
     */
    expectedType?: DataType;
    /**
     * The assigned type from the expression.
     */
    assignedType?: DataType;
}

/**
 * Creates a `IncorrectTypeError` object with the given arguments
 */
export const makeIncorrectTypeError = (value?: OmitPartial<IncorrectTypeError, '$kind', 'suggestions'>): IncorrectTypeError => ({
    $kind: BotElementDiagnosticKind.IncorrectTypeError,
    suggestions: [],
    ...value
});


/**
 * Static analysis error from an expression
 */
export interface ExpressionError extends BotElementError
{
    readonly $kind: BotElementDiagnosticKind.ExpressionError;
    /**
     * The character position where this error started
     */
    startPosition?: number;
    /**
     * The character position where this error ended
     */
    endPosition?: number;
    errorCode?: ExpressionErrorCode;
}

/**
 * Creates a `ExpressionError` object with the given arguments
 */
export const makeExpressionError = (value?: OmitPartial<ExpressionError, '$kind', 'suggestions'>): ExpressionError => ({
    $kind: BotElementDiagnosticKind.ExpressionError,
    suggestions: [],
    ...value
});


/**
 * Error when the property/ariable has an invalid type. (e.g. we don't authorize Any type for the variable)
 */
export interface InvalidVariableType extends BotElementError
{
    readonly $kind: BotElementDiagnosticKind.InvalidVariableType;
    /**
     * The property's path
     */
    variable?: PropertyPath;
    /**
     * The property's data type
     */
    variableType?: DataType;
}

/**
 * Creates a `InvalidVariableType` object with the given arguments
 */
export const makeInvalidVariableType = (value?: OmitPartial<InvalidVariableType, '$kind', 'suggestions'>): InvalidVariableType => ({
    $kind: BotElementDiagnosticKind.InvalidVariableType,
    suggestions: [],
    ...value
});


/**
 * Represents an error related to a property on the node. Property can be of any type.
 */
export interface PropertyError extends PropertyErrorBase
{
    readonly $kind: BotElementDiagnosticKind.PropertyError;
    errorCode: ValidationErrorCode;
}

/**
 * Creates a `PropertyError` object with the given arguments
 */
export const makePropertyError = (value: OmitPartial<PropertyError, '$kind', 'suggestions'>): PropertyError => ({
    $kind: BotElementDiagnosticKind.PropertyError,
    suggestions: [],
    ...value
});


/**
 * Represents an error related to an item in the list property. Compared to PropertyError class, it allows specifying the index.
 */
export interface ListPropertyItemError extends PropertyErrorBase
{
    readonly $kind: BotElementDiagnosticKind.ListPropertyItemError;
    errorCode: ValidationErrorCode;
    index: number;
}

/**
 * Creates a `ListPropertyItemError` object with the given arguments
 */
export const makeListPropertyItemError = (value: OmitPartial<ListPropertyItemError, '$kind', 'suggestions'>): ListPropertyItemError => ({
    $kind: BotElementDiagnosticKind.ListPropertyItemError,
    suggestions: [],
    ...value
});


/**
 * Represents an error related to an item in the dictionary property. Compared to PropertyError class, it allows specifying the key.
 */
export interface DictionaryPropertyItemError extends PropertyErrorBase
{
    readonly $kind: BotElementDiagnosticKind.DictionaryPropertyItemError;
    errorCode: ValidationErrorCode;
    key: string;
}

/**
 * Creates a `DictionaryPropertyItemError` object with the given arguments
 */
export const makeDictionaryPropertyItemError = (value: OmitPartial<DictionaryPropertyItemError, '$kind', 'suggestions'>): DictionaryPropertyItemError => ({
    $kind: BotElementDiagnosticKind.DictionaryPropertyItemError,
    suggestions: [],
    ...value
});


/**
 * Error when node references another resource or node but it wasn't found. (e.g. flow, skill, dialog not found)
 */
export interface InvalidReferenceError extends BotElementError
{
    readonly $kind: BotElementDiagnosticKind.InvalidReferenceError;
    referenceType?: ReferenceType;
    referenceId?: string;
    errorCode: InvalidReferenceErrorCode;
}

/**
 * Creates a `InvalidReferenceError` object with the given arguments
 */
export const makeInvalidReferenceError = (value: OmitPartial<InvalidReferenceError, '$kind', 'suggestions'>): InvalidReferenceError => ({
    $kind: BotElementDiagnosticKind.InvalidReferenceError,
    suggestions: [],
    ...value
});


/**
 * Error when node has a binding error
 */
export interface BindingError extends BotElementError
{
    bindingKey: string;
}



/**
 * Error when we read output or write to input of the action but it was not found.
 */
export interface BindingKeyNotFoundError extends BindingError
{
    readonly $kind: BotElementDiagnosticKind.BindingKeyNotFoundError;
}

/**
 * Creates a `BindingKeyNotFoundError` object with the given arguments
 */
export const makeBindingKeyNotFoundError = (value: OmitPartial<BindingKeyNotFoundError, '$kind', 'suggestions'>): BindingKeyNotFoundError => ({
    $kind: BotElementDiagnosticKind.BindingKeyNotFoundError,
    suggestions: [],
    ...value
});


/**
 * Error when we assign an incorrect type to the input
 */
export interface BindingIncorrectTypeError extends BindingError
{
    readonly $kind: BotElementDiagnosticKind.BindingIncorrectTypeError;
    typeError: IncorrectTypeError;
}

/**
 * Creates a `BindingIncorrectTypeError` object with the given arguments
 */
export const makeBindingIncorrectTypeError = (value: OmitPartial<BindingIncorrectTypeError, '$kind', 'suggestions'>): BindingIncorrectTypeError => ({
    $kind: BotElementDiagnosticKind.BindingIncorrectTypeError,
    suggestions: [],
    ...value
});


/**
 * Error when node mutates the system variable
 */
export interface ReadOnlyVariableMutationError extends BotElementError
{
    readonly $kind: BotElementDiagnosticKind.ReadOnlyVariableMutationError;
    variableName?: string;
}

/**
 * Creates a `ReadOnlyVariableMutationError` object with the given arguments
 */
export const makeReadOnlyVariableMutationError = (value?: OmitPartial<ReadOnlyVariableMutationError, '$kind', 'suggestions'>): ReadOnlyVariableMutationError => ({
    $kind: BotElementDiagnosticKind.ReadOnlyVariableMutationError,
    suggestions: [],
    ...value
});


/**
 * Error when node is unknown to the system
 */
export interface UnknownElementError extends BotElementError
{
    readonly $kind: BotElementDiagnosticKind.UnknownElementError;
}

/**
 * Creates a `UnknownElementError` object with the given arguments
 */
export const makeUnknownElementError = (value?: OmitPartial<UnknownElementError, '$kind', 'suggestions'>): UnknownElementError => ({
    $kind: BotElementDiagnosticKind.UnknownElementError,
    suggestions: [],
    ...value
});


/**
 * Represents a single suggestion that the user can apply to fix the issue
 */
export interface BotElementSuggestion
{
    readonly $kind: BotElementSuggestionKind;
}



export interface ChangeDialogContractSuggestion extends BotElementSuggestion
{
    readonly $kind: BotElementSuggestionKind.ChangeDialogContractSuggestion;
    dialog: DialogSchemaName;
    parameter: string;
    targetType: DataType;
}

/**
 * Creates a `ChangeDialogContractSuggestion` object with the given arguments
 */
export const makeChangeDialogContractSuggestion = (value: Omit<ChangeDialogContractSuggestion, '$kind'>): ChangeDialogContractSuggestion => ({
    $kind: BotElementSuggestionKind.ChangeDialogContractSuggestion,
    ...value
});


/**
 * Provide diagnostic details on the variables that are in scope for a given dialog or node.
 */
export interface VariableInformationDiagnostic extends BotElementDiagnostic
{
    readonly $kind: BotElementDiagnosticKind.VariableInformationDiagnostic;
    /**
     * Scope of the variable. If null, then the variable is a system variable.
     */
    scope?: VariableScope;
    /**
     * Unique name of the variable within the scope.
     */
    name: string;
    /**
     * Full path to the variable including the scope
     */
    path: PropertyPath;
    /**
     * Whether the variable is readonly. Majority of system variables are read only.
     */
    isReadOnly: boolean;
    /**
     * Data type of the variable
     */
    type: DataType;
    /**
     * If the type is an option set, contains the options in the option set.
     */
    optionSetOptions: OptionInfo[];
    /**
     * Information about the variable's initializer. Null if there is no initializer.
     */
    initializerInfo?: InitializerInfo;
    /**
     * Whether the variable can be set externally, such as from the channel or from a browser.
     */
    isExternalInitializationAllowed: boolean;
    /**
     * Components that have Variable declarations for this variable
     */
    declaringComponents: string[];
    /**
     * The property is not shown in the list of variables, but is shown in the expression autcomplete
     */
    isHidden?: boolean;
}

/**
 * Creates a `VariableInformationDiagnostic` object with the given arguments
 */
export const makeVariableInformationDiagnostic = (value: OmitPartial<VariableInformationDiagnostic, '$kind', 'optionSetOptions' | 'declaringComponents'>): VariableInformationDiagnostic => ({
    $kind: BotElementDiagnosticKind.VariableInformationDiagnostic,
    optionSetOptions: [],
    declaringComponents: [],
    ...value
});


/**
 * Information about the initializer of a variable. Contains either InitializingExpression or InitializingActionReference, but not both.
 */
export interface InitializerInfo
{
    /**
     * Information about the expression that initializes this variable.
     */
    initializingExpression?: ValueExpression;
    /**
     * A reference to the action that initializes this variable.
     */
    initializingActionReference?: ActionReference;
}



export interface OptionInfo
{
    value: OptionName;
    displayName?: string;
}



/**
 * Base element representing structured condition editor elements.
 */
export interface BooleanConditionBase extends BotElement
{
}



/**
 * Base element reprenting a collection of conditions.
 */
export interface BooleanConditionGroup extends BooleanConditionBase
{
    conditions: BooleanConditionBase[];
}



/**
 * All Conditions in this group are joined together by an AND expression
 */
export interface AndConditionGroup extends BooleanConditionGroup
{
    readonly $kind: BotElementKind.AndConditionGroup;
}

/**
 * Creates a `AndConditionGroup` object with the given arguments
 */
export const makeAndConditionGroup = (value?: OmitPartial<AndConditionGroup, '$kind', 'conditions' | 'diagnostics'>): AndConditionGroup => ({
    $kind: BotElementKind.AndConditionGroup,
    conditions: [],
    diagnostics: [],
    ...value
});


/**
 * All Conditions in this group are joined together by an OR expression
 */
export interface OrConditionGroup extends BooleanConditionGroup
{
    readonly $kind: BotElementKind.OrConditionGroup;
}

/**
 * Creates a `OrConditionGroup` object with the given arguments
 */
export const makeOrConditionGroup = (value?: OmitPartial<OrConditionGroup, '$kind', 'conditions' | 'diagnostics'>): OrConditionGroup => ({
    $kind: BotElementKind.OrConditionGroup,
    conditions: [],
    diagnostics: [],
    ...value
});


/**
 * Represents a single binary or unary comparison.
 */
export interface BooleanCondition extends BooleanConditionBase
{
    readonly $kind: BotElementKind.BooleanCondition;
    variable: PropertyPath;
    operator: BooleanConditionOperator;
    value?: ValueExpression;
}

/**
 * Creates a `BooleanCondition` object with the given arguments
 */
export const makeBooleanCondition = (value: OmitPartial<BooleanCondition, '$kind', 'diagnostics'>): BooleanCondition => ({
    $kind: BotElementKind.BooleanCondition,
    diagnostics: [],
    ...value
});


export interface WasmCommand
{
    readonly $kind: WasmCommandKind;
    /**
     * Helps to correlate the command sent to Wasm with a message sent from Wasm to the client. Also, helps in the debugging.
     */
    commandId: string;
}



/**
 * Cancels existing command. The cancellation is not guaranteed. Should be used for perf reasons to cancel slow commands we are not interested anymore.
 */
export interface CancelCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.CancelCommand;
    commandIdToCancel: string;
}

/**
 * Creates a `CancelCommand` object with the given arguments
 */
export const makeCancelCommand = (value: Omit<CancelCommand, '$kind'>): CancelCommand => ({
    $kind: WasmCommandKind.CancelCommand,
    ...value
});


export interface ConvertFileFormatCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.ConvertFileFormatCommand;
    content: string;
    isSourceYaml?: boolean;
}

/**
 * Creates a `ConvertFileFormatCommand` object with the given arguments
 */
export const makeConvertFileFormatCommand = (value: Omit<ConvertFileFormatCommand, '$kind'>): ConvertFileFormatCommand => ({
    $kind: WasmCommandKind.ConvertFileFormatCommand,
    ...value
});


export interface ActionContextInfo
{
    dialogSchemaName: DialogSchemaName;
    triggerId: TriggerId;
    dialogActionId: ActionId;
}



/**
 * Command responsible for PowerFx autocomplete and expression validation
 */
export interface PowerFxLanguageServerCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.PowerFxLanguageServerCommand;
    requestJson: string;
    context?: ActionContextInfo;
}

/**
 * Creates a `PowerFxLanguageServerCommand` object with the given arguments
 */
export const makePowerFxLanguageServerCommand = (value: Omit<PowerFxLanguageServerCommand, '$kind'>): PowerFxLanguageServerCommand => ({
    $kind: WasmCommandKind.PowerFxLanguageServerCommand,
    ...value
});


/**
 * The first command that loads the bot in the Wasm state. It resets all previous state. Response command: LoadBotCommandResponse
 */
export interface LoadBotCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.LoadBotCommand;
    bot?: BotDefinition;
    enabledFeatures: string[];
}

/**
 * Creates a `LoadBotCommand` object with the given arguments
 */
export const makeLoadBotCommand = (value: OmitPartial<LoadBotCommand, '$kind', 'enabledFeatures'>): LoadBotCommand => ({
    $kind: WasmCommandKind.LoadBotCommand,
    enabledFeatures: [],
    ...value
});


export interface GetVariableReferencesCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.GetVariableReferencesCommand;
    variablePath: PropertyPath;
    /**
     * Dialog should be provided if the variable is dialog level variable or a dialog/trigger/action level scoped system variable. Dialog is ignored for global variables and thus it can always be provided.
     */
    dialog?: DialogSchemaName;
}

/**
 * Creates a `GetVariableReferencesCommand` object with the given arguments
 */
export const makeGetVariableReferencesCommand = (value: Omit<GetVariableReferencesCommand, '$kind'>): GetVariableReferencesCommand => ({
    $kind: WasmCommandKind.GetVariableReferencesCommand,
    ...value
});


/**
 * Retrieves variables based on the bot's current state in WASM
 */
export interface GetVariablesCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.GetVariablesCommand;
    /**
     * If null, global and bot level system variables are returned
     */
    dialogSchemaName?: DialogSchemaName;
    /**
     * If null, all dialog, global and bot level system variables are returned (trigger specific system variables are not returned)
     */
    triggerId?: TriggerId;
    /**
     * If not null, then we return only dialog variables that may exist in this action
     */
    dialogActionId?: ActionId;
}

/**
 * Creates a `GetVariablesCommand` object with the given arguments
 */
export const makeGetVariablesCommand = (value: Omit<GetVariablesCommand, '$kind'>): GetVariablesCommand => ({
    $kind: WasmCommandKind.GetVariablesCommand,
    ...value
});


/**
 * Loads user's or external changes to the components. Response command: LoadBotCommandResponse
 */
export interface LoadBotChangesCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.LoadBotChangesCommand;
    /**
     * List of created or modified components to apply in Wasm state
     */
    upsertComponents: SolutionComponent[];
    /**
     * List of bot components to delete from Wasm state
     */
    deleteComponents: string[];
    /**
     * List of flows that need to delete from Wasm state
     */
    deleteFlows: FlowId[];
    /**
     * List of environment varaibles to delete from wasm state
     */
    deleteEnvVariables: EnvironmentVariableDefinitionSchemaName[];
}

/**
 * Creates a `LoadBotChangesCommand` object with the given arguments
 */
export const makeLoadBotChangesCommand = (value: OmitPartial<LoadBotChangesCommand, '$kind', 'upsertComponents' | 'deleteComponents' | 'deleteFlows' | 'deleteEnvVariables'>): LoadBotChangesCommand => ({
    $kind: WasmCommandKind.LoadBotChangesCommand,
    upsertComponents: [],
    deleteComponents: [],
    deleteFlows: [],
    deleteEnvVariables: [],
    ...value
});


/**
 * Validates the bot in its current state. Command doesn't await all pending edit commands.
 */
export interface ValidateBotCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.ValidateBotCommand;
}

/**
 * Creates a `ValidateBotCommand` object with the given arguments
 */
export const makeValidateBotCommand = (value: Omit<ValidateBotCommand, '$kind'>): ValidateBotCommand => ({
    $kind: WasmCommandKind.ValidateBotCommand,
    ...value
});


/**
 * Gets the dialog/variable/skill in the asked state.
 */
export interface GetComponentCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.GetComponentCommand;
    /**
     * The schema name of the bot component to return.
     */
    schemaName?: string;
    /**
     * If true then the validated component will be returned. 
     */
    validate?: boolean;
}

/**
 * Creates a `GetComponentCommand` object with the given arguments
 */
export const makeGetComponentCommand = (value: Omit<GetComponentCommand, '$kind'>): GetComponentCommand => ({
    $kind: WasmCommandKind.GetComponentCommand,
    ...value
});


/**
 * Updates a variable to the desired state. Can be used to change scope, name, or make a variable a dialog input/output. Response command: UpdateVariableCommandResponse
 */
export interface UpdateVariableCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.UpdateVariableCommand;
    dialogSchemaName: DialogSchemaName;
    /**
     * The path of the variable to change
     */
    variablePath: PropertyPath;
    /**
     * The desired scope of the variable
     */
    targetScope: VariableScope;
    /**
     * The desired name of the variable, without scope prefix
     */
    targetName: string;
}

/**
 * Creates a `UpdateVariableCommand` object with the given arguments
 */
export const makeUpdateVariableCommand = (value: Omit<UpdateVariableCommand, '$kind'>): UpdateVariableCommand => ({
    $kind: WasmCommandKind.UpdateVariableCommand,
    ...value
});


/**
 * Command to get all loaded bot content
 */
export interface GetSerializedContentCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.GetSerializedContentCommand;
}

/**
 * Creates a `GetSerializedContentCommand` object with the given arguments
 */
export const makeGetSerializedContentCommand = (value: Omit<GetSerializedContentCommand, '$kind'>): GetSerializedContentCommand => ({
    $kind: WasmCommandKind.GetSerializedContentCommand,
    ...value
});


/**
 * Gets the provided content as YAML.
 */
export interface GetSerializedElementsCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.GetSerializedElementsCommand;
    /**
     * The content to serialize as YAML.
     */
    content: BotElement[];
}

/**
 * Creates a `GetSerializedElementsCommand` object with the given arguments
 */
export const makeGetSerializedElementsCommand = (value: OmitPartial<GetSerializedElementsCommand, '$kind', 'content'>): GetSerializedElementsCommand => ({
    $kind: WasmCommandKind.GetSerializedElementsCommand,
    content: [],
    ...value
});


/**
 * Gets the provided yaml content as a list of BotElements.
 */
export interface ParseElementsCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.ParseElementsCommand;
    /**
     * The $kind value that is expected from the root element.
     */
    requiredKind?: BotElementKind;
    /**
     * The serialized content in YAML format. Can be a single object or a list of objects
     */
    content?: string;
}

/**
 * Creates a `ParseElementsCommand` object with the given arguments
 */
export const makeParseElementsCommand = (value: Omit<ParseElementsCommand, '$kind'>): ParseElementsCommand => ({
    $kind: WasmCommandKind.ParseElementsCommand,
    ...value
});


/**
 * Command that applies a suggestion and re-validates the dialog
 */
export interface ApplyBotElementSuggestionCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.ApplyBotElementSuggestionCommand;
    /**
     * Suggestion to apply
     */
    suggestion?: BotElementSuggestion;
    /**
     * If true, then the changes will be saved in the current state. If false, changes will be returned but not stored in current state.
     */
    saveChangesInCurrentState?: boolean;
}

/**
 * Creates a `ApplyBotElementSuggestionCommand` object with the given arguments
 */
export const makeApplyBotElementSuggestionCommand = (value: Omit<ApplyBotElementSuggestionCommand, '$kind'>): ApplyBotElementSuggestionCommand => ({
    $kind: WasmCommandKind.ApplyBotElementSuggestionCommand,
    ...value
});


export interface WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind;
    /**
     * Helps to correlate the command sent to Wasm with a message sent from Wasm to the client. Also, helps in the debugging.
     */
    commandId: string;
}



export interface LoadBotCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.LoadBotCommandResponse;
    /**
     * Flows that are used in the bot but theirs definitions are missing and should be loaded.
     */
    missingFlows: FlowId[];
    /**
     * Environment variables that are used in the bot but theirs definitions are missing and should be loaded.
     */
    missingEnvironmentVariables: EnvironmentVariableDefinitionSchemaName[];
}

/**
 * Creates a `LoadBotCommandResponse` object with the given arguments
 */
export const makeLoadBotCommandResponse = (value: OmitPartial<LoadBotCommandResponse, '$kind', 'missingFlows' | 'missingEnvironmentVariables'>): LoadBotCommandResponse => ({
    $kind: WasmCommandResponseKind.LoadBotCommandResponse,
    missingFlows: [],
    missingEnvironmentVariables: [],
    ...value
});


/**
 * The response to ApplyBotElementSuggestion. It returns changed bot components
 */
export interface ApplyBotElementSuggestionCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ApplyBotElementSuggestionCommandResponse;
    components: BotComponentBase[];
}

/**
 * Creates a `ApplyBotElementSuggestionCommandResponse` object with the given arguments
 */
export const makeApplyBotElementSuggestionCommandResponse = (value: OmitPartial<ApplyBotElementSuggestionCommandResponse, '$kind', 'components'>): ApplyBotElementSuggestionCommandResponse => ({
    $kind: WasmCommandResponseKind.ApplyBotElementSuggestionCommandResponse,
    components: [],
    ...value
});


/**
 * Informs the client that there was an error during the execution of the command.
 */
export interface ErrorCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ErrorCommandResponse;
    error: string;
    commandType: string;
}

/**
 * Creates a `ErrorCommandResponse` object with the given arguments
 */
export const makeErrorCommandResponse = (value: Omit<ErrorCommandResponse, '$kind'>): ErrorCommandResponse => ({
    $kind: WasmCommandResponseKind.ErrorCommandResponse,
    ...value
});


export interface VariableReferenceInfo
{
    dialogSchemaName: DialogSchemaName;
    triggerId: TriggerId;
    actionId: ActionId;
    /**
     * If true then the action is assigning the variable. If false, then the action is reading the variable
     */
    isVariableAssigning: boolean;
}



export interface GetVariableReferencesCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.GetVariableReferencesCommandResponse;
    references: VariableReferenceInfo[];
}

/**
 * Creates a `GetVariableReferencesCommandResponse` object with the given arguments
 */
export const makeGetVariableReferencesCommandResponse = (value: OmitPartial<GetVariableReferencesCommandResponse, '$kind', 'references'>): GetVariableReferencesCommandResponse => ({
    $kind: WasmCommandResponseKind.GetVariableReferencesCommandResponse,
    references: [],
    ...value
});


export interface OptionSetInfo
{
    optionSetType?: OptionSetDataType;
    /**
     * List of the options in the option set.
     */
    options: OptionInfo[];
}



export interface GetVariablesCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.GetVariablesCommandResponse;
    variables: VariableInformationDiagnostic[];
    /**
     * The list includes global, system, current dialog option sets and also option sets of the dialogs referenced by the current dialog
     */
    optionSets: OptionSetInfo[];
}

/**
 * Creates a `GetVariablesCommandResponse` object with the given arguments
 */
export const makeGetVariablesCommandResponse = (value: OmitPartial<GetVariablesCommandResponse, '$kind', 'variables' | 'optionSets'>): GetVariablesCommandResponse => ({
    $kind: WasmCommandResponseKind.GetVariablesCommandResponse,
    variables: [],
    optionSets: [],
    ...value
});


/**
 * Validates the bot in its current state. Command doesn't await all pending edit commands.
 */
export interface ValidateBotCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ValidateBotCommandResponse;
    components: BotComponentBase[];
}

/**
 * Creates a `ValidateBotCommandResponse` object with the given arguments
 */
export const makeValidateBotCommandResponse = (value: OmitPartial<ValidateBotCommandResponse, '$kind', 'components'>): ValidateBotCommandResponse => ({
    $kind: WasmCommandResponseKind.ValidateBotCommandResponse,
    components: [],
    ...value
});


export interface GetComponentCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.GetComponentCommandResponse;
    /**
     * Component with validation and diagnostics info
     */
    component?: BotComponentBase;
}

/**
 * Creates a `GetComponentCommandResponse` object with the given arguments
 */
export const makeGetComponentCommandResponse = (value: Omit<GetComponentCommandResponse, '$kind'>): GetComponentCommandResponse => ({
    $kind: WasmCommandResponseKind.GetComponentCommandResponse,
    ...value
});


export interface GetSerializedElementsCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.GetSerializedElementsCommandResponse;
    /**
     * The serialized content in YAML format
     */
    content?: string;
}

/**
 * Creates a `GetSerializedElementsCommandResponse` object with the given arguments
 */
export const makeGetSerializedElementsCommandResponse = (value: Omit<GetSerializedElementsCommandResponse, '$kind'>): GetSerializedElementsCommandResponse => ({
    $kind: WasmCommandResponseKind.GetSerializedElementsCommandResponse,
    ...value
});


export interface ParseElementsCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ParseElementsCommandResponse;
    /**
     * The content deserialized from YAML.
     */
    content: BotElement[];
    /**
     * Whether the content is valid for use in the authoring canvas.
     */
    isContentValid?: boolean;
    /**
     * Any errors that occurred. Only present if IsContentValid is false.
     */
    errorMessage?: string;
}

/**
 * Creates a `ParseElementsCommandResponse` object with the given arguments
 */
export const makeParseElementsCommandResponse = (value: OmitPartial<ParseElementsCommandResponse, '$kind', 'content'>): ParseElementsCommandResponse => ({
    $kind: WasmCommandResponseKind.ParseElementsCommandResponse,
    content: [],
    ...value
});


export interface PowerFxLanguageServerCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.PowerFxLanguageServerCommandResponse;
    /**
     * PowerFx language server response
     */
    response: string[];
}

/**
 * Creates a `PowerFxLanguageServerCommandResponse` object with the given arguments
 */
export const makePowerFxLanguageServerCommandResponse = (value: OmitPartial<PowerFxLanguageServerCommandResponse, '$kind', 'response'>): PowerFxLanguageServerCommandResponse => ({
    $kind: WasmCommandResponseKind.PowerFxLanguageServerCommandResponse,
    response: [],
    ...value
});


export interface ConvertFileFormatCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ConvertFileFormatCommandResponse;
    content?: string;
}

/**
 * Creates a `ConvertFileFormatCommandResponse` object with the given arguments
 */
export const makeConvertFileFormatCommandResponse = (value: Omit<ConvertFileFormatCommandResponse, '$kind'>): ConvertFileFormatCommandResponse => ({
    $kind: WasmCommandResponseKind.ConvertFileFormatCommandResponse,
    ...value
});


export interface UpdateVariableCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.UpdateVariableCommandResponse;
    /**
     * Dialog component with the updated variable
     */
    dialogComponent?: DialogComponent;
}

/**
 * Creates a `UpdateVariableCommandResponse` object with the given arguments
 */
export const makeUpdateVariableCommandResponse = (value: Omit<UpdateVariableCommandResponse, '$kind'>): UpdateVariableCommandResponse => ({
    $kind: WasmCommandResponseKind.UpdateVariableCommandResponse,
    ...value
});


/**
 * Retrieves the current transfer state.
 */
export interface ExtractTransferStateCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.ExtractTransferStateCommand;
}

/**
 * Creates a `ExtractTransferStateCommand` object with the given arguments
 */
export const makeExtractTransferStateCommand = (value: Omit<ExtractTransferStateCommand, '$kind'>): ExtractTransferStateCommand => ({
    $kind: WasmCommandKind.ExtractTransferStateCommand,
    ...value
});


/**
 * Loads the transfer state into the state, overwriting existing state if it exists
 */
export interface ApplyTransferStateCommand extends WasmCommand
{
    readonly $kind: WasmCommandKind.ApplyTransferStateCommand;
    state: TransferState;
}

/**
 * Creates a `ApplyTransferStateCommand` object with the given arguments
 */
export const makeApplyTransferStateCommand = (value: Omit<ApplyTransferStateCommand, '$kind'>): ApplyTransferStateCommand => ({
    $kind: WasmCommandKind.ApplyTransferStateCommand,
    ...value
});


export interface ExtractTransferStateCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ExtractTransferStateCommandResponse;
    state: TransferState;
}

/**
 * Creates a `ExtractTransferStateCommandResponse` object with the given arguments
 */
export const makeExtractTransferStateCommandResponse = (value: Omit<ExtractTransferStateCommandResponse, '$kind'>): ExtractTransferStateCommandResponse => ({
    $kind: WasmCommandResponseKind.ExtractTransferStateCommandResponse,
    ...value
});


export interface ApplyTransferStateCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.ApplyTransferStateCommandResponse;
}

/**
 * Creates a `ApplyTransferStateCommandResponse` object with the given arguments
 */
export const makeApplyTransferStateCommandResponse = (value: Omit<ApplyTransferStateCommandResponse, '$kind'>): ApplyTransferStateCommandResponse => ({
    $kind: WasmCommandResponseKind.ApplyTransferStateCommandResponse,
    ...value
});


export interface TransferState
{
    /**
     * The state of the bot
     */
    bot?: BotDefinition;
    enabledFeatures: string[];
}



export interface GetSerializedContentCommandResponse extends WasmCommandResponse
{
    readonly $kind: WasmCommandResponseKind.GetSerializedContentCommandResponse;
    content?: string;
}

/**
 * Creates a `GetSerializedContentCommandResponse` object with the given arguments
 */
export const makeGetSerializedContentCommandResponse = (value: Omit<GetSerializedContentCommandResponse, '$kind'>): GetSerializedContentCommandResponse => ({
    $kind: WasmCommandResponseKind.GetSerializedContentCommandResponse,
    ...value
});


/**
 * Hook up ILogger interface to the browser Telemetry/Logger
 */
export interface WasmLog
{
    readonly $kind: WasmLogKind;
    categoryName: string;
    id: string;
}



export interface WasmBrowserActivityLog extends WasmLog
{
    readonly $kind: WasmLogKind.WasmBrowserActivityLog;
    activity: string;
    /**
     * Duration in milliseconds
     */
    duration: number;
    dimensions: Dictionary<string>;
    createdTimeUtc: DateTime;
}

/**
 * Creates a `WasmBrowserActivityLog` object with the given arguments
 */
export const makeWasmBrowserActivityLog = (value: OmitPartial<WasmBrowserActivityLog, '$kind', 'dimensions'>): WasmBrowserActivityLog => ({
    $kind: WasmLogKind.WasmBrowserActivityLog,
    dimensions: {},
    ...value
});


export interface WasmBrowserTelemetryLog extends WasmLog
{
    readonly $kind: WasmLogKind.WasmBrowserTelemetryLog;
    message: string;
    createdTimeUtc: DateTime;
    logLevel: WasmBrowserTelemetryLogLevel;
}

/**
 * Creates a `WasmBrowserTelemetryLog` object with the given arguments
 */
export const makeWasmBrowserTelemetryLog = (value: Omit<WasmBrowserTelemetryLog, '$kind'>): WasmBrowserTelemetryLog => ({
    $kind: WasmLogKind.WasmBrowserTelemetryLog,
    ...value
});


export type EnumExpression<T> = ExpressionBase<T> & { $kind: BotElementKind.EnumExpression_T };
/**
 * Creates a `EnumExpression<T>` object with the given arguments
 */
export const makeEnumExpression_T = <T>(value?: OmitPartial<EnumExpression<T>, '$kind', 'diagnostics'>): EnumExpression<T> => ({
    $kind: BotElementKind.EnumExpression_T,
    diagnostics: [],
    ...value
});

export type ArrayExpression<T> = ExpressionBase<T[]> & { $kind: BotElementKind.ArrayExpression_T };
/**
 * Creates a `ArrayExpression<T>` object with the given arguments
 */
export const makeArrayExpression_T = <T>(value?: OmitPartial<ArrayExpression<T>, '$kind', 'literalValue' | 'diagnostics'>): ArrayExpression<T> => ({
    $kind: BotElementKind.ArrayExpression_T,
    literalValue: [],
    diagnostics: [],
    ...value
});

export type ObjectExpression<T> = ExpressionBase<T> & { $kind: BotElementKind.ObjectExpression_T };
/**
 * Creates a `ObjectExpression<T>` object with the given arguments
 */
export const makeObjectExpression_T = <T>(value?: OmitPartial<ObjectExpression<T>, '$kind', 'diagnostics'>): ObjectExpression<T> => ({
    $kind: BotElementKind.ObjectExpression_T,
    diagnostics: [],
    ...value
});

export type ValueExpression = ExpressionBase<DataValue> & { $kind: BotElementKind.ValueExpression };
/**
 * Creates a `ValueExpression` object with the given arguments
 */
export const makeValueExpression = (value?: OmitPartial<ValueExpression, '$kind', 'diagnostics'>): ValueExpression => ({
    $kind: BotElementKind.ValueExpression,
    diagnostics: [],
    ...value
});

export type BoolExpression = ExpressionBase<boolean> & { $kind: BotElementKind.BoolExpression, structuredCondition?: BooleanConditionGroup };
/**
 * Creates a `BoolExpression` object with the given arguments
 */
export const makeBoolExpression = (value?: OmitPartial<BoolExpression, '$kind', 'diagnostics'>): BoolExpression => ({
    $kind: BotElementKind.BoolExpression,
    diagnostics: [],
    ...value
});

export type NumberExpression = ExpressionBase<number> & { $kind: BotElementKind.NumberExpression };
/**
 * Creates a `NumberExpression` object with the given arguments
 */
export const makeNumberExpression = (value?: OmitPartial<NumberExpression, '$kind', 'diagnostics'>): NumberExpression => ({
    $kind: BotElementKind.NumberExpression,
    diagnostics: [],
    ...value
});

export type IntExpression = ExpressionBase<number> & { $kind: BotElementKind.IntExpression };
/**
 * Creates a `IntExpression` object with the given arguments
 */
export const makeIntExpression = (value?: OmitPartial<IntExpression, '$kind', 'diagnostics'>): IntExpression => ({
    $kind: BotElementKind.IntExpression,
    diagnostics: [],
    ...value
});

export type StringExpression = ExpressionBase<string> & { $kind: BotElementKind.StringExpression };
/**
 * Creates a `StringExpression` object with the given arguments
 */
export const makeStringExpression = (value?: OmitPartial<StringExpression, '$kind', 'diagnostics'>): StringExpression => ({
    $kind: BotElementKind.StringExpression,
    diagnostics: [],
    ...value
});

export type DialogExpression = ExpressionBase<DialogSchemaName> & { $kind: BotElementKind.DialogExpression };
/**
 * Creates a `DialogExpression` object with the given arguments
 */
export const makeDialogExpression = (value: OmitPartial<DialogExpression, '$kind', 'diagnostics'>): DialogExpression => ({
    $kind: BotElementKind.DialogExpression,
    diagnostics: [],
    ...value
});

